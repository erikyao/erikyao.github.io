<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Erik Yao's</title>
        <description>Erik Yao's - Erik Yao</description>
        <link>http://erikyao.github.io</link>
        <link>http://erikyao.github.io</link>
        <lastBuildDate>2014-05-22T21:24:56+08:00</lastBuildDate>
        <pubDate>2014-05-22T21:24:56+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>局部内部类、匿名内部类对外部变量的访问权限 + 闭包</title>
                <description>&lt;h2&gt;局部内部类对外部变量的访问权限&lt;/h2&gt;

&lt;p&gt;　　&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html&quot;&gt;Local Class 的文档&lt;/a&gt; 有说：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;A local class has access to the members of its enclosing class.&lt;br/&gt;
&lt;br/&gt;
In addition, a local class has access to local variables. However, a local class can only access local variables that are declared final.&lt;br/&gt;
&lt;br/&gt;
However, starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or effectively final. A variable or parameter whose value is never changed after it is initialized is effectively final.&lt;/p&gt;&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2&gt;匿名内部类对外部变量的访问权限&lt;/h2&gt;

&lt;p&gt;　　&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html#accessing&quot;&gt;Anonymous Class 的文档&lt;/a&gt; 有说：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;An anonymous class has access to the members of its enclosing class.&lt;br/&gt;
&lt;br/&gt;
An anonymous class cannot access local variables in its enclosing scope that are not declared as final or effectively final.&lt;/p&gt;&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2&gt;闭包&lt;/h2&gt;

&lt;p&gt;　　以上两点限制的原因，一种论调是：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;the local class instance can remain in memory after the method returns. When the method returns the local variables go out of scope, so a copy of them is needed. If the variables weren’t final then the copy of the variable in the method could change, while the copy in the local class didn’t, so they’d be out of synch.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　有人说是编译器实现策略，也有人说这一种伪闭包实现。我比较认同，这就是一种实现策略，并不是什么原则性的问题。&lt;/p&gt;

&lt;p&gt;　　那么，什么是闭包呢？&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_%28computer_science%29&quot;&gt;英文维基&lt;/a&gt; 说：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In programming languages, a closure (also lexical closure or function closure) is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function. A closure—unlike a plain function pointer—allows a function to access those non-local variables even when invoked outside its immediate lexical scope.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　&lt;a href=&quot;http://zh.wikipedia.org/zh/%E9%97%AD%E5%8C%85_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29&quot;&gt;中文维基&lt;/a&gt; 说：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。&lt;br/&gt;
&lt;br/&gt;
在 C 语言中，支持回调函数的库有时在注册时需要两个参数：一个函数指针，一个独立的 void* 指针用以保存用户数据。这样的做法允许回调函数恢复其调用时的状态。这样的惯用法在功能上类似于闭包，但语法上有所不同。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　C 语言的这个例子举得很容易理解。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2014/05/18/accessbility-of-the-member-of-the-enclosing-class</link>
                <guid>http://erikyao.github.io/java/2014/05/18/accessbility-of-the-member-of-the-enclosing-class</guid>
                <pubDate>2014-05-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>win7 图标显示不正常如何解决</title>
                <description>&lt;p&gt;　　重建图标缓存不用重启，先打开 WINRAR，然后打开任务管理器，找到 explorer.exe 结束该进程（一定要先结束，否则后续删除  Iconcache.db 也不会起作用）。&lt;br/&gt;
　　然后在 WINRAR 地址栏里输入：%userprofile%\appdata\local\，点击确认，在下面找到 Iconcache.db，将这个文件删除。&lt;br/&gt;
　　然后再在任务管理器里重新打开explorer.exe进程就行了。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/windows/2013/07/24/win7-icon-failure</link>
                <guid>http://erikyao.github.io/windows/2013/07/24/win7-icon-failure</guid>
                <pubDate>2013-07-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>shallow copy v.s. deep clone</title>
                <description>

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Field implements Cloneable {  
    public String name;  
      
    @Override  
    protected Object clone() {  
        Field f;  
        try {  
            f = (Field) super.clone(); // shallow clone  
            // f.name = new String(this.name); // deep clone  
              
            return f;  
        } catch (CloneNotSupportedException e) {  
            e.printStackTrace();  
        }  
        return null;  
    }  
    
    public static void main(String[] args) {
        Field f1 = new Field();
        f1.name = &quot;test&quot;;
        Field f2 = (Field) f1.clone();
        
        System.out.println(f1.name == f2.name); // true
    }
}  
&lt;/pre&gt;


&lt;p&gt;　　shallow clone 时要注意对象中的字段是可变类还是不可变类。比如上面的例子中，Field 中的字段是 String，不可变类，所以 f.name = &quot;world&quot;; 不会影响到 f.clone().name；如果是 StringBuffer 或是 Collection 这类的可变类，f.name.append(); 或是 f.name.sort(); 一下，f.clone().name 也会跟着变，所以就不是标准的 clone 了。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2011/11/01/shallow-copy-and-deep-clone</link>
                <guid>http://erikyao.github.io/java/2011/11/01/shallow-copy-and-deep-clone</guid>
                <pubDate>2011-11-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>阻止 form submit 的方法</title>
                <description>&lt;p&gt;　　有两个地方可以可以阻止 form submit，一是 &lt;code&gt;&amp;lt;form onsubmit=&quot;&quot;&amp;gt;&lt;/code&gt; ，二是 &amp;lt;form&amp;gt; 下的 &lt;code&gt;&amp;lt;input type=&quot;submit&quot; onclick=&quot;&quot;&amp;gt;&lt;/code&gt; ，只要这两个函数有一个是 return false;，那么点击这个 button 并不会 submit form。&lt;/p&gt;

&lt;p&gt;　　具体的执行流程是这样的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
if (submitInput.onclick() == false) {  
    // 不触发 form.onsubmit();  
    // form 不提交;  
} else {  
    // 触发 form.onsubmit();  
    if (form.onsubmit() == false) {  
        // form 不提交  
    } else {  
        // 提交 form  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;所以在这个两个函数里面可以加一些验证工作，同时，可以根据验证结果来判断是否提交form。比如有：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
var checkForm = function() {  
    // 获取输入  
    if (校验失败)  
        return false；  
    else  
        return true；  
}  
&lt;/pre&gt;


&lt;p&gt;然后把这个函数写到 onsubmit 或是 onclick，也可以针对不同的 button 写不同的逻辑的校验函数，比如这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;html&amp;gt;  
    &amp;lt;form onsubmit=&quot;return checkFormStep2();&quot; method=&quot;post&quot; action=&quot;/XXX.do&quot;&amp;gt;  
        &amp;lt;input type=&quot;text&quot; id=&quot;username&quot;&amp;gt;  
        &amp;lt;input type=&quot;password&quot; id=&quot;password&quot;&amp;gt;  
  
        &amp;lt;input type=&quot;submit&quot; onclick=&quot;return checkFormStep1();&quot; value=&quot;go&quot; /&amp;gt;  
    &amp;lt;/form&amp;gt;  
&amp;lt;/html&amp;gt;  
&lt;/pre&gt;


&lt;p&gt;在点击时先执行 checkFormStep1()，在 form 提交前再执行 checkFormStep2()，两个都通过都 return true 了才提交。&lt;/p&gt;

&lt;p&gt;　　也可以针对 “撤销” 功能的按钮写一些类似清空输入的功能，再禁止它提交 form，比如这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;html&amp;gt;  
    &amp;lt;form method=&quot;post&quot; action=&quot;/XXX.do&quot;&amp;gt;  
        &amp;lt;input type=&quot;text&quot; id=&quot;username&quot;&amp;gt;  
        &amp;lt;input type=&quot;password&quot; id=&quot;password&quot;&amp;gt;  
  
        &amp;lt;input type=&quot;submit&quot; onclick=&quot;return checkFormStep();&quot; value=&quot;go&quot; /&amp;gt;  
        &amp;lt;input type=&quot;submit&quot; onclick=&quot;clearInput(); return false;&quot; value=&quot;reset&quot; /&amp;gt;  
    &amp;lt;/form&amp;gt;  
&amp;lt;/html&amp;gt;  
&lt;/pre&gt;

</description>
                <link>http://erikyao.github.io/html/2011/10/18/how-to-prevent-form-submitting</link>
                <guid>http://erikyao.github.io/html/2011/10/18/how-to-prevent-form-submitting</guid>
                <pubDate>2011-10-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>static 属性的注入必须使用非 static 的 setter</title>
                <description>&lt;p&gt;　　有一些 util 类或是 config 类会用到 static 属性，这些 util 类或是 config 类也可以通过 Spring 来初始化，和初始化一个 POJO 没什么区别，虽然实际应用中不太可能去创建一个 util 对象或是 config 对象，一般都是使用 static getter 而已。&lt;/p&gt;

&lt;p&gt;　　但如果要使用 Spring 来初始化，那么这些 static 属性不能用 static 的 setter 来注入，否则 NotWritablePropertyException。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/spring/2011/09/02/static-injection</link>
                <guid>http://erikyao.github.io/spring/2011/09/02/static-injection</guid>
                <pubDate>2011-09-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>"Could not resolve placeholder" 解决方案</title>
                <description>&lt;p&gt;　　除去 properites 文件路径错误、拼写错误外，出现 &quot;Could not resolve placeholder&quot; 很有可能是使用了多个 &lt;code&gt;PropertyPlaceholderConfigurer&lt;/code&gt; 或者多个 &lt;code&gt;&amp;lt;context:property-placeholder&amp;gt;&lt;/code&gt; 的原因。&lt;/p&gt;

&lt;p&gt;　　比如我有一个 dao.xml 读取 dbConnect.properties，还有一个 dfs.xml 读取 dfsManager.properties，然后 web.xml 统一 load 这两个 xml 文件&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;context-param&amp;gt;  
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;  
    &amp;lt;param-value&amp;gt;  
            WEB-INF/config/spring/dao.xml,   
            WEB-INF/config/spring/dfs.xml  
    &amp;lt;/param-value&amp;gt;  
&amp;lt;/context-param&amp;gt; 
&lt;/pre&gt;


&lt;p&gt;如果这两个 xml 文件中分别有：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;context:property-placeholder location=&quot;WEB-INF/config/db/dbConnect.properties&quot; /&amp;gt;  
&lt;/pre&gt;




&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;context:property-placeholder location=&quot;WEB-INF/config/dfs/dfsManager.properties&quot; /&amp;gt;  
&lt;/pre&gt;


&lt;p&gt;那么，一定会出 &quot;Could not resolve placeholder&quot;。&lt;/p&gt;

&lt;p&gt;　　一定要记住，不管是在一个 Spring 文件还是在多个 Spring 文件被统一 load 的情况下，直接写：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;context:property-placeholder location=&quot;&quot; /&amp;gt;  
&amp;lt;context:property-placeholder location=&quot;&quot; /&amp;gt;  
&lt;/pre&gt;


&lt;p&gt;是不允许的。&lt;/p&gt;

&lt;p&gt;　　解决方案：&lt;/p&gt;

&lt;p&gt;　　(1) 在 Spring 3.0 中，可以写：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;context:property-placeholder location=&quot;xxx.properties&quot; ignore-unresolvable=&quot;true&quot; /&amp;gt;    
&amp;lt;context:property-placeholder location=&quot;yyy.properties&quot; ignore-unresolvable=&quot;true&quot; /&amp;gt;   
&lt;/pre&gt;


&lt;p&gt;注意两个都要加上ignore-unresolvable=&quot;true&quot;，一个加另一个不加也是不行的&lt;/p&gt;

&lt;p&gt;　　(2) 在Spring 2.5中，&lt;code&gt;&amp;lt;context:property-placeholder&amp;gt;&lt;/code&gt; 没有 ignore-unresolvable 属性，此时可以改用 PropertyPlaceholderConfigurer。其实 &lt;code&gt;&amp;lt;context:property-placeholder location=&quot;xxx.properties&quot; ignore-unresolvable=&quot;true&quot; /&amp;gt;&lt;/code&gt; 与下面的配置是等价的&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;bean id=&quot;随便&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&amp;gt;  
    &amp;lt;property name=&quot;location&quot; value=&quot;xxx.properties&quot; /&amp;gt;  
    &amp;lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot; /&amp;gt;   
&amp;lt;/bean&amp;gt; 
&lt;/pre&gt;


&lt;p&gt;正因为如此，写多个 PropertyPlaceholderConfigurer 不加 ignoreUnresolvablePlaceholders 属性也是一样会出 &quot;Could not resolve placeholder&quot;。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/spring/2011/08/17/could-not-resolve-placeholder-solution</link>
                <guid>http://erikyao.github.io/spring/2011/08/17/could-not-resolve-placeholder-solution</guid>
                <pubDate>2011-08-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>MySQL 5.5 版本下 my.ini 内 [mysqld] 项中不能再写 default-character-set=utf8</title>
                <description>&lt;p&gt;　　原来在 5.1 版本时，为了解决中文乱码问题设置默认字符集为 utf8 时，在 my.ini 内的 [mysql] 和 [mysqld] 项中都是写：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
default-character-set=utf8  
&lt;/pre&gt;


&lt;p&gt;　　到了 5.5 版本， [mysql] 项内可以这么写， [mysqld] 项内不能再这么写了，而是必须写：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
character-set-server=utf8  
&lt;/pre&gt;


&lt;p&gt;否则在启动MySQL服务时会有1067错误。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/mysql/2011/07/11/default-character-set-no-longer-an-option-in-mysql-5-5</link>
                <guid>http://erikyao.github.io/mysql/2011/07/11/default-character-set-no-longer-an-option-in-mysql-5-5</guid>
                <pubDate>2011-07-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>有关 Java 的 main 方法</title>
                <description>

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public static void main(String[] args) {  
    ...  
}
&lt;/pre&gt;


&lt;h2&gt;1、关于 main 方法中的修饰符 public&lt;/h2&gt;

&lt;p&gt;　　main 方法是个特殊的方法，它是 JDK/JRE 约定的运行应用程序的启动入口方法，如果你用 java.exe 运行一个 class，它就会在这个 class 里面寻找这个方法，并调用它，等它返回了，程序也就结束了。JVM 规范并没有要求 main 一定是 public 的，你用其他修饰符也不会有编译错误，只是在执行时，JVM 会提示 main 方法的修饰符不是 public，JVM 无法启动应用程序。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;2、关于 main 方法中的 static&lt;/h2&gt;

&lt;p&gt;　　main 方法必须是一个静态方法，因为 JVM 是直接访问 main 方法的，事先不用先创建 main class 对象，直接运行应用程序。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;3、main 方法的 return type 必须为 void&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2&gt;4、main 方法只作为 Java 应用程序的入口&lt;/h2&gt;

&lt;p&gt;　　比如 Applet 程序就不需要 main() 方法，其入口程序一般为 init() 方法。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;5、main 可作为普通方法名&lt;/h2&gt;

&lt;p&gt;　　不符合 main 方法严格定义的其他 main 方法将视为 class 的普通方法。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;6、main 可以用 final 来修饰。&lt;/h2&gt;
</description>
                <link>http://erikyao.github.io/java/2010/10/10/main-method</link>
                <guid>http://erikyao.github.io/java/2010/10/10/main-method</guid>
                <pubDate>2010-10-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Java 多线程：synchronized</title>
                <description>&lt;p&gt;　　首先明确一点，同步方法本质上也是一个同步控制块（仅针对于锁定 this 的情况，如果同步控制块锁定的不是 this，那么它是不能直接改写为同步方法的），区别在于同步方法的粒度是整个方法，而同步控制块的粒度可以是方法的一部分。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
// 同步方法示例  
public class Counter {  
    int count;  
    static int classCount;  
      
    public synchronized void bump() {  
        System.out.println(&quot;bump() starts&quot;);  
        count++;  
        try {  
            Thread.sleep(1000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
        System.out.println(&quot;bump() ends&quot;);  
    }  
      
    public static synchronized void classBump() {  
        classCount++;  
        System.out.println(&quot;classBump()&quot;);  
    }  
}  
  
// 同步方法可以等价地写成同步控制块  
public class Counter {  
    int count;  
    static int classCount;  
      
    public void bump() {  
        synchronized (this) {  
            // ...  
        }  
    }  
      
    public static void classBump() {  
        synchronized (Counter.class) {  
            // ...  
        }  
          
        // 或者不用Counter.class，用Class.forName()  
        /** 
        try { 
            synchronized (Class.forName(&quot;Counter&quot;)) { 
                // ... 
            } 
        } catch (ClassNotFoundException e) { 
            e.printStack(); 
        } 
        */  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;　　从这个例子可以看出，Class 锁（针对 static 方法）和 Object 锁（针对非 static 方法）是两种锁。从实验的结果来看，这两种锁是不冲突的，即：假设有 Counter c = new Counter();，如果 Thread A 调用 c.bump() 方法，那么 synchronized(this) 只是锁定了 c 这个对象，Thread B 可以无所顾忌地调用 Counter.classBump()（或者 c.classBump() 也可以），不用等待 Thread A 释放 c 的锁。如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class MultiThreadTest8 {  
    public static void main(String[] args) {  
        final Counter c = new Counter();  
          
        Thread t1 = new Thread(  
                new Runnable() {  
                    @Override public void run() {  
                        c.bump();  
                    }  
                }, &quot;Runner 1&quot;);  
          
        Thread t2 = new Thread(  
                new Runnable() {  
                    @Override public void run() {  
                        //Counter.classBump();  
                        c.classBump();  
                    }  
                }, &quot;Runner 2&quot;);  
          
        t1.setPriority(Thread.NORM_PRIORITY + 2);  
        t1.start();  
        t2.start();  
          
        // output:   
        /** 
            bump() starts 
            classBump() 
            bump() ends      
        */  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;　　不过一旦 Thread A 调用 c.bump()，锁定了 c，那么 Thread B 就不能调用 c.bump() 了，c 中的其他同步方法或是同步控制块 Thread B 也不能访问，只有等到 Thread A 释放 c 的锁（即 c.bump() 同步部分执行完）。Counter 的非同步方法不受锁的限制，即使 Thread A 锁定了 c，Thread B 也可以随意访问 c 的非同步方法。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;p.s.&lt;/em&gt; 这里说锁定一个对象，并不是说属性不能访问，锁定对象只是锁定同步方法或是同步控制块，使同步方法或是同步控制块的执行不会被其他线程打断（可以理解为：锁定方法到一个线程）。如果有一个同步方法去修改某个字段，此时是可以有另一个非同步方法也去修改这个字段，这样仍然有可能产生数据不一致的情况。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;p.s.&lt;/em&gt; synchronized 关键字可以放在类的前面，表示类中的所有方法都是同步方法。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2010/10/05/synchronized</link>
                <guid>http://erikyao.github.io/java/2010/10/05/synchronized</guid>
                <pubDate>2010-10-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Java 多线程：Runnable 接口 v.s. Thread 类</title>
                <description>

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class Runner implements Runnable {  
    @Override  
    public void run() {  
        for(int i = 0; i &lt; 100; i++) {  
            System.out.println(&quot;Runner runs to --&gt; &quot; + i);  
        }  
    }  
}  
&lt;/pre&gt;




&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class MultiThreadTest {  
  
    public static void main(String[] args) {  
        Runner r = new Runner();  
        //r.run(); // 方法调用，没有启动新线程  
  
        Thread t = new Thread(r);  
        //t.run(); // 方法调用，没有启动新线程  
        t.start(); // 启动新线程  
          
        for(int i = 0; i &lt; 200; i++) {  
            System.out.println(&quot;Main goes &quot; + i);   
        }  
    } 
}  
&lt;/pre&gt;


&lt;p&gt;　　Runnable 接口和 Thread 类的关系：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先有 Thread implememts Runnable&lt;/li&gt;
&lt;li&gt;虽说 Runnable 有一个方法 run()，但基本上 Runnable 可以看做是一个标记接口；Runnable 本身并不提供多线程机制，只有 Thread 类才能启动新线程；Runnable 的实现类只有传递给 Thread 构造器才有意义&lt;/li&gt;
&lt;li&gt;Thread.run() 默认会调用传递给 Thread 构造器的 Runnable 实现类的 run()，如果没有 Runnable 实现类传进来的话，Thraed.run() 方法什么都不做直接返回&lt;/li&gt;
&lt;li&gt;Thread.run() &lt;em&gt;&lt;strong&gt;并不能&lt;/strong&gt;&lt;/em&gt; 启动新线程（相当于一般的方法调用，直接调用 Runnable 实现类的 run() 方法亦是如此），&lt;em&gt;&lt;strong&gt;只有&lt;/strong&gt;&lt;/em&gt; Thread.start() 方法才能启动新线程；Thread.start() 方法会调用 Thread.run() 方法&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定制自己的线程类的方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;class Runner implements Runnable，实现 run() 方法，然后 Thread t = new Thread(new Ruuner()); t.start();&lt;/li&gt;
&lt;li&gt;class MyThread extends Thread，覆写 run() 方法，然后 MyThread mt = new MyThread(); mt.start();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 这两种方式又涉及到 “接口还是继承” 的设计原则问题了&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://erikyao.github.io/java/2010/10/04/runnable-vs-thread</link>
                <guid>http://erikyao.github.io/java/2010/10/04/runnable-vs-thread</guid>
                <pubDate>2010-10-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Java 多线程：终止线程的方法</title>
                <description>&lt;p&gt;　　虽说 Thread 类提供了 stop() 和 suspend() 方法，但这两种方法过于粗暴，如果线程占用了一些资源（如打开了一个文件，建立了一个数据库连接什么的），直接 stop() 或是 suspend() 是会产生问题的。&lt;/p&gt;

&lt;p&gt;　　要终止 Thread，最好的方法就是让 run() 方法正常运行完毕，不过有的 run() 方法里面直接是一个 while (true)，这时就要使用一些特殊的手段。&lt;/p&gt;

&lt;h2&gt;1. 使用中断&lt;/h2&gt;

&lt;p&gt;　　基本思想就是在 run() 方法中的 while (true) 里检查线程是否中断，如果中断就退出（当然，退出之前可以做一些关闭资源的操作）；这么一来在主线程中就可以调用 Thread.interrupt() 来中断线程，进而使线程退出。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class Runner3 implements Runnable {     
    @Override    
    public void run() {     
        while(true) {     
            System.out.println(new Date());     
                 
            long time = System.currentTimeMillis();     
            while (System.currentTimeMillis() - time &lt; 1000) {     
                // 不使用Thread.sleep(1000)     
                // 使用while来消耗一秒钟时间     
            }     
                 
            if (Thread.currentThread().isInterrupted()) { // 时刻检查该线程是否中断     
            // 或者使用 if (Thread.interrupted()) {     
                return; // 如果线程中断就退出     
            }     
        }     
    }     
}    
&lt;/pre&gt;




&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class MultiThreadTest3 {     
    public static void main(String[] args) {     
        Runner3 r = new Runner3();     
    
        Thread t = new Thread(r);     
        t.start();     
             
        try {     
            Thread.sleep(10000);     
        } catch (InterruptedException e) {     
            // do nothing     
        }     
             
        t.interrupt(); // 中断Thread t，使run()方法退出，线程结束     
    }     
}    
&lt;/pre&gt;


&lt;p&gt;如果在 run() 方法中的 while (true) 里有可能导致 InterruptedException 的操作，那么退出 run() 方法的代码可以放在 catch 语句里。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class Runner2 implements Runnable {  
    @Override  
    public void run() {  
        while(true) {  
            System.out.println(new Date());  
              
            try {  
                Thread.sleep(1000);  
            } catch (InterruptedException e) {  
                return; // 发生中断异常时，线程直接退出  
            }  
        }  
    }  
}   
&lt;/pre&gt;




&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class MultiThreadTest2 {     
    public static void main(String[] args) {     
        Runner2 r = new Runner2();     
    
        Thread t = new Thread(r);     
        t.start();     
             
        try {     
            Thread.sleep(10000);     
        } catch (InterruptedException e) {     
            // do nothing     
        }     
             
        t.interrupt(); // 中断Thread t，使t.sleep()时产生中断异常，进而终止线程     
    }     
}    
&lt;/pre&gt;


&lt;h2&gt;2. 使用标志位&lt;/h2&gt;

&lt;p&gt;　　使用标志位 boolean flag，将 run() 方法中的 while (true) 改为while (flag)（轮询标志位），主线程中就就可以通过修改 flag 来退出线程。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class Runner4 implements Runnable {  
    private boolean flag = true;  
      
    public void setFlag(boolean flag) {  
        this.flag = flag;  
    }  
  
    @Override  
    public void run() {  
        while(flag) {  
            System.out.println(new Date());  
              
            long time = System.currentTimeMillis();  
            while (System.currentTimeMillis() - time &lt; 1000) {  
                // 不使用Thread.sleep(1000)  
                // 使用while来消耗一秒钟时间  
            }  
        }  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class MultiThreadTest4 {  
    public static void main(String[] args) {  
        Runner4 r = new Runner4();  
  
        Thread t = new Thread(r);  
        t.start();  
          
        try {  
            Thread.sleep(10000);  
        } catch (InterruptedException e) {  
            // do nothing  
        }  
          
        r.setFlag(false); // 设置标志位，使run()方法退出，线程结束  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;这个方法有一个缺点：如果 while (flag) {...} 方法阻塞了，则 flag 的设置会失效。&lt;/p&gt;

&lt;h2&gt;3. 最好的方法是使用线程池&lt;/h2&gt;

&lt;p&gt;　　当线程不用了，就让它 sleep 并放进队列中，这样可以最大限度地利用资源。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2010-10-04补充&lt;/em&gt;：&lt;/p&gt;

&lt;p&gt;　　注意这里说的退出是这样的一种情况：主线程（比如说 main 方法）创建了一个 Thread t，然后想在主线程中使t退出。&lt;br/&gt;
　　文章一开始说的 stop()、suspend() 方法的问题是：主线程一句 t.stop() 或是 t.suspend() 就了事了，t 在 run() 方法中没有机会去关闭资源，不像中断或是轮询标志位的方法中，t 在 run() 方法里还握有一点主动权&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011-11-03补充&lt;/em&gt;：&lt;/p&gt;

&lt;p&gt;　　方法 2 可以使用的一个优化步骤是将标志位设置为 volatile&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2010/10/04/how-to-terminate-a-thread</link>
                <guid>http://erikyao.github.io/java/2010/10/04/how-to-terminate-a-thread</guid>
                <pubDate>2010-10-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Const Pointer</title>
                <description>&lt;h2&gt;（1）&lt;/h2&gt;

&lt;p&gt;　　首先确定一点，int const i; 与 const int i 是一样的，都是定义一个只读的 int i。&lt;/p&gt;

&lt;h2&gt;（2）&lt;/h2&gt;

&lt;p&gt;　　所以 int const *p; 与 const int *p; 也是一样的，都是定义一个只读的 int *p。但是，不管是 int const *p; 还是 const int *p;，这里有几点需要注意：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
#include &lt;stdio.h&gt;  
  
int main()   
{  
    int i1 = 30;  
    int i2 = 40;  
    const int *p = &amp;i1;  
      
    p = &amp;i2; // no problem  
    i2 = 80;  
    printf(&quot;%d\n&quot;, *p); // output: 80  
      
    // *p = 100; // error: assignment of read-only location  
      
    return 0;  
} &lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;首先是 *p 只读，并不是 p 只读，所以 p 的值是可以改的（p = &amp;i2;）&lt;/li&gt;
&lt;li&gt;第二，&amp;amp;i1 只是一个 int *，所以把一个int * 赋值给 const int * 是可以的（const int *p = &amp;i1;）&lt;/li&gt;
&lt;li&gt;第三，p = &amp;i2; 之后，对 &amp;amp;i2 这块地址的访问就有两种方式，一是非 const 的 i2，二是 const 的 *p，所以可以有 i2 = 80;，而不能有 *p = 100;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;（3）&lt;/h2&gt;

&lt;p&gt;　　int * const p; 是定义了一个只读的 p，所以假如有 int * const p = &amp;i1; 之后，就不能再有 p = &amp;i2;了。但是 *p 的值是可以随便改的。&lt;/p&gt;

&lt;h2&gt;（4）&lt;/h2&gt;

&lt;p&gt;　　把一个 const int * 赋值给 int * 也是可以的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
#include &lt;stdio.h&gt;  
  
int main()   
{     
    const int ci = 200;  
    int *p3 = &amp;ci;  
      
    *p3 = 250;  
    printf(&quot;%d\n&quot;, *p3); // output: 250  
      
    return 0;  
} &lt;/pre&gt;


&lt;p&gt;这样其实是可以去修改一个 const int 的……&lt;/p&gt;

&lt;h2&gt;（5）&lt;/h2&gt;

&lt;p&gt;　　const int * const p; 就是说 p 和 *p 都是只读的，结合（2）、（3）即可得它的特性。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/c/2010/09/26/const-pointer</link>
                <guid>http://erikyao.github.io/c/2010/09/26/const-pointer</guid>
                <pubDate>2010-09-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>hibernate 延迟加载的错误</title>
                <description>&lt;p&gt;　　异常信息：&lt;code&gt;failed to lazily initialize a collection of role: &amp;lt;容器类对象&amp;gt;, no session or session was closed&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　这个问题一般出现在 @OneToMany 的情况下，解决的方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果是 xml 配置，在 hbm 文件中的对应属性上配置 lazy=&quot;false&quot;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果是用 annotation，则配置如下：&lt;/p&gt;

&lt;p&gt; &lt;pre class=&quot;prettyprint linenums&quot;&gt;
 @OneToMany(
 　　targetEntity = CourseAuthorizationItem.class,
 　　cascade = { CascadeType.PERSIST, CascadeType.MERGE },
 　　mappedBy = &quot;xxx&quot;, fetch = FetchType.EAGER
 ) &lt;/pre&gt;&lt;/p&gt;

&lt;p&gt; 将 fetch 类型设置成直接获取&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://erikyao.github.io/hibernate/2010/08/28/failed-to-lazily-initialize-a-collection-of-role</link>
                <guid>http://erikyao.github.io/hibernate/2010/08/28/failed-to-lazily-initialize-a-collection-of-role</guid>
                <pubDate>2010-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring TestContext 测试框架中 @BeforeClass 方法无法使用 @ContextConfiguration 初始化的 bean</title>
                <description>&lt;p&gt;　　例如我们有：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
@ContextConfiguration(locations = {&quot;classpath:datasource.xml&quot;, &quot;classpath:process-engine.xml&quot;})  
public class ProcessConfigurationManagerTest extends AbstractJUnit4SpringContextTests {  
    ……  
}  
&lt;/pre&gt;


&lt;p&gt;　　在写 @BeforeClass 方法时，datasource.xml 和 process-engine.xml 这两个文件并没有读取，所以不能实例化 bean。也就是说这两个文件的读取在 @BeforeClass 之后。@BeforeClass 方法中就不能使用这两个 xml 文件中配置的 bean，否则直接是 NullPointerException。&lt;/p&gt;

&lt;p&gt;　　在 @Before 方法中就不会有这中情况。&lt;/p&gt;

&lt;p&gt;　　遇到两次了，谨记。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;P.S.&lt;/em&gt;：一个 annotation 类型被定义为 @Retent(RetentionPolicy.RUNTIME) 后，它才是在运行时可见，当 class 文件被装载时被保存在 class 文件中的 annotation 才会被虚拟机读取。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/spring/2010/08/11/contextconfiguration-initializes-after-beforeclass-method</link>
                <guid>http://erikyao.github.io/spring/2010/08/11/contextconfiguration-initializes-after-beforeclass-method</guid>
                <pubDate>2010-08-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>callback 释义</title>
                <description>&lt;p&gt;　　最近接触到了 HibernateTemplate，用到了 HibernateCallback，决定把 callback 的逻辑关系彻底搞清楚，以前总是不明白这个 call 到底是谁 call 的谁，这个 back 到底是从哪里 back 到哪里。&lt;/p&gt;

&lt;p&gt;　　要搞清楚英文原文的逻辑，还是 wikipedia 好使，反正我关键字 “回调函数” 搜了半天也没搞清楚……&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In computer programming, a callback is a reference to executable code, or a piece of executable code, that is passed as an argument to other code. This allows a lower-level software layer to call a subroutine (or function) defined in a higher-level layer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://fqc6qg.bn1.livefilestore.com/y2pfs7LgSHiY5NfY22KjQoUXtC-P18Ntk21T0GZSzuuM6MH0ES7k_yo-6UUI1iW902P5iCumZSNIoxQOrc3KcAN1FHR8vfq4PWtnsckBs0jzVw/625px-Callback-notitle.svg.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　从这个解释和图来看，callback function 的指针会传递给 library function，然后 library function calls callback function, from library level back to appliaction level。callback function 实质是被回调的函数。&lt;/p&gt;

&lt;p&gt;　　callback 在 MFC 中体现得很明显。我们设计的 dialog、button 什么的都是 Main program，写的 onButtonOK()、onWindowClose() 这类的事件处理函数就是 Callback function，它们都是我们开发的 Application program；MFC 底层运行机制就是 Library function，是属于 Software library 的。&lt;/p&gt;

&lt;p&gt;　　这个层次关系在 HibernateTemplate 中并不是很明显，因为 HibernateCallback 也是 library 的一部分，相当于是给了 application 一个默认实现。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/os/2010/08/08/callback</link>
                <guid>http://erikyao.github.io/os/2010/08/08/callback</guid>
                <pubDate>2010-08-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring AOP 学习（四）：简单 XML 配置 </title>
                <description>&lt;p&gt;　　紧接着 &lt;a href=&quot;/aop/2010/08/02/learning-spring-aop-part-3-example-and-basic-concept/&quot;&gt;Spring AOP 学习（三）：例子与基本概念&lt;/a&gt; 中的例子。其实 Spring AOP 注解的概念理解了后，看 XML 配置就是件很简单的事情了。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;  
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;  
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
           http://www.springframework.org/schema/context  
           http://www.springframework.org/schema/context/spring-context-2.5.xsd  
           http://www.springframework.org/schema/aop  
           http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&amp;gt;  
    &amp;lt;context:annotation-config /&amp;gt;  
    &amp;lt;context:component-scan base-package=&quot;com.bjsxt&quot;/&amp;gt;  
  
    &amp;lt;bean id=&quot;logInterceptor&quot; class=&quot;com.bjsxt.aop.LogInterceptor&quot;&amp;gt;&amp;lt;/bean&amp;gt;  
    &amp;lt;aop:config&amp;gt;  
        &amp;lt;aop:pointcut expression=&quot;execution(public * com.bjsxt.service..*.add(..))&quot; id=&quot;logPointCut&quot;/&amp;gt;  
        &amp;lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;logInterceptor&quot;&amp;gt;  
            &amp;lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;logPointCut&quot; /&amp;gt;  
        &amp;lt;/aop:aspect&amp;gt;  
    &amp;lt;/aop:config&amp;gt;  
&amp;lt;/beans&amp;gt;  
&lt;/pre&gt;


&lt;ol&gt;
&lt;li&gt;首先去掉了 &lt;code&gt;&amp;lt;aop:aspectj-autoproxy /&amp;gt;&lt;/code&gt; 这句&lt;/li&gt;
&lt;li&gt;还是得先初始化一个 LogInteceptor 对象，所以要先写一个 &amp;lt;bean&amp;gt;&lt;/li&gt;
&lt;li&gt;AOP 的配置写在 &lt;code&gt;&amp;lt;aop:config&amp;gt;&amp;lt;/aop:config&amp;gt;&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;调用 add() 方法时，Spring 发现符合 pointcut(&quot;logPointCut&quot;)，然后这个 poincut 又被 aspect(&quot;logAspect&quot;) 引用到了，所以就去执行相应的切面逻辑&lt;/li&gt;
&lt;li&gt;上面定义了一个全局的 pointcut(&quot;logPointCut&quot;)，这意味着其他的 aspect 都可以通过 id 引用这个 pointcut。其实也可以将 pointcut 写在 aspect 内，这样相当于一个私有 pointcut，其他的 aspect 无法引用这个 pointcut（因为没有 id）：&lt;/li&gt;
&lt;/ol&gt;


&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;bean id=&quot;logInterceptor&quot; class=&quot;com.bjsxt.aop.LogInterceptor&quot;&amp;gt;&amp;lt;/bean&amp;gt;  
&amp;lt;aop:config&amp;gt;    
    &amp;lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;logInterceptor&quot;&amp;gt;  
        &amp;lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public * com.bjsxt.service..*.add(..))&quot; /&amp;gt;  
    &amp;lt;/aop:aspect&amp;gt;  
&amp;lt;/aop:config&amp;gt;  
&lt;/pre&gt;


&lt;p&gt;　　某些情况下，要使用别人的切面类（比如一个测量代码性能的工具，要把测量的逻辑织入你自己的代码），这时你不可能在别人的切面类代码上加注解，所以只有通过 XML 来配置。目前在实际使用中，XML 的使用也是多于注解。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/aop/2010/08/02/learning-spring-aop-part-4-basic-xml-config</link>
                <guid>http://erikyao.github.io/aop/2010/08/02/learning-spring-aop-part-4-basic-xml-config</guid>
                <pubDate>2010-08-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring AOP 学习（三）：例子与基本概念</title>
                <description>&lt;p&gt;　　依旧是 LogInterceptor 的例子。下面是 beans.xml：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;  
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;  
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
           http://www.springframework.org/schema/context  
           http://www.springframework.org/schema/context/spring-context-2.5.xsd  
           http://www.springframework.org/schema/aop  
           http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&amp;gt;  
    &amp;lt;context:annotation-config /&amp;gt;  
    &amp;lt;context:component-scan base-package=&quot;com.bjsxt&quot;/&amp;gt;  
    &amp;lt;aop:aspectj-autoproxy /&amp;gt;  
&amp;lt;/beans&amp;gt;  
&lt;/pre&gt;


&lt;p&gt;注意添加 aop 的 namespace 和 &lt;code&gt;&amp;lt;aop:aspectj-autoproxy /&amp;gt;&lt;/code&gt; 这一句。LogInterceptor 的代码如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package com.bjsxt.aop;  
  
import org.aspectj.lang.ProceedingJoinPoint;  
import org.aspectj.lang.annotation.Around;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.annotation.Before;  
import org.aspectj.lang.annotation.Pointcut;  
import org.springframework.stereotype.Component;  
  
@Aspect  
@Component  
public class LogInterceptor {  
    @Pointcut(&quot;execution(public * com.bjsxt.service..*.add(..))&quot;)  
    public void myMethod(){};  
      
    @Before(&quot;myMethod()&quot;)  
    public void before() {  
        System.out.println(&quot;method before&quot;);  
    }  
      
    @Around(&quot;myMethod()&quot;)  
    public void aroundMethod(ProceedingJoinPoint pjp) throws Throwable {  
        System.out.println(&quot;method around start&quot;);  
        pjp.proceed();  
        System.out.println(&quot;method around end&quot;);  
    }    
}  
&lt;/pre&gt;


&lt;p&gt;这里需要注意两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;这里 &lt;strong&gt;必须要有 @Component&lt;/strong&gt;，让 Spring 来 new 一个 LoginInterceptor 对象（我们定义了 &lt;code&gt;&amp;lt;context:component-scan base-package=&quot;com.bjsxt&quot;/&amp;gt;&lt;/code&gt;; 来让 Spring 来扫描 com.bjsxt 包；扫描到 @Aspect 就知道要织入这个类了）。这样才能把 LoginInterceptor 对象织入 UserDAOImpl&lt;/li&gt;
&lt;li&gt;&lt;code&gt;execution(public void com.bjsxt.dao.UserDAOImpl.save(com.bjsxt.model.User)&quot;)&lt;/code&gt;，这是 &lt;strong&gt;AspectJ 语法&lt;/strong&gt;，execution 表示在方法执行时切入。另有其他的切入点，比如属性初始化时、类加载时&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　根据这个例子，我们来理解一些 AOP 的概念：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Target&lt;/em&gt;: UserDAOImpl 是织入的 Target&lt;/li&gt;
&lt;li&gt;&lt;em&gt;JoinPoint&lt;/em&gt;: &lt;code&gt;execution(public void save())&lt;/code&gt; 这里就是 JoinPoint，即 &lt;strong&gt;切入点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Advice&lt;/em&gt;: before() 方法是 Advice，&lt;strong&gt;Advice is an action taken by an Aspect at a certain JoinPoint&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;AdviceType&lt;/em&gt;: @Before 是 AdviceType，表示这是一个 Advice that executes before a JoinPoint&lt;/li&gt;
&lt;li&gt;&lt;em&gt;PointCut&lt;/em&gt;: 从通配符（&lt;code&gt;@Pointcut(&quot;execution(public * com.bjsxt.service.*.add(.))&lt;/code&gt;)）可以看出，&lt;strong&gt;PointCut 是 JoinPoint 的集合&lt;/strong&gt;，但是注意 &lt;strong&gt;PointCut 必须依赖于一个方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Aspect&lt;/em&gt;: LogInterceptor 这个类，或者说 LogInterceptor 这个类的逻辑（即记录日志）是一个 Aspect&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://erikyao.github.io/aop/2010/08/02/learning-spring-aop-part-3-example-and-basic-concept</link>
                <guid>http://erikyao.github.io/aop/2010/08/02/learning-spring-aop-part-3-example-and-basic-concept</guid>
                <pubDate>2010-08-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>jBPM-4.3 流程定义 zip 包中的所有文件都是资源</title>
                <description>

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
ZipInputStream zis = new ZipInputStream(new FileInputStream(&quot;process.jpdl.zip&quot;));  
  
processEngine.getRepositoryService().createDeployment().addResourcesFromZipInputStream(zis).deploy();  
&lt;/pre&gt;


&lt;p&gt;　　如果是部署的是 zip 包，那么 zip 包中的所有文件都是可用的资源。换句话说，你可以把杂七杂八的文件都放在 zip 包中一起部署。比如现在我的 process.jpdl.zip 里面不仅有 process.jpdl.xml 和 process.png，还有一个 resource.xml，那么这个 resource.xml 也是可以被获取到的，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
Set&lt;String&gt; resourceSet = processEngine.getRepositoryService().getResourceNames(deployId);  
for (String s : resourceSet) {  
    System.out.println(s);   
}

// Output:   
// resource.xml  
// process.jpdl.xml  
// process.png  
&lt;/pre&gt;


&lt;p&gt;除了得到资源的 InputStream 外：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
ByteArrayInputStream bis = (ByteArrayInputStream)processEngine.getRepositoryService().getResourceAsStream(deployId, &quot;resource.xml&quot;);  
&lt;/pre&gt;


&lt;p&gt;资源还可以被动态修改，不过要注意，动态修改资源这个方法在 RepositoryServiceImpl 中，RepositoryService 接口并没有暴露这个方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
is2 = new FileInputStream(&quot;newResource.xml&quot;);  
  
RepositoryServiceImpl rsi = (RepositoryServiceImpl)processEngine.getRepositoryService();  
rsi.updateDeploymentResource(deployId, &quot;resource.xml&quot;, is2);  
&lt;/pre&gt;


&lt;p&gt;这样就把 newResource.xml 的内容写入了 resource.xml 中（覆盖原有内容），此时再获取 resource.xml 的 InputStream，输出出来的结果就是 newResource.xml 的内容&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/jbpm-4.3/2010/07/29/what-is-resource-in-jbpm-4-3</link>
                <guid>http://erikyao.github.io/jbpm-4.3/2010/07/29/what-is-resource-in-jbpm-4-3</guid>
                <pubDate>2010-07-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>jBPM-4.3 &lt;process&gt; 标签 name 属性中的短横线会变成下划线赋给 key 属性</title>
                <description>&lt;p&gt;　　假设我部署了一个 jpdl.xml，&amp;lt;process name=&quot;test-vehicle&quot;&amp;gt;，那么，查询出的 ProcessDefinition 的属性如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
System.out.println(pd.getName());    // definitionName == &quot;test-vehicle&quot;  
System.out.println(pd.getKey());       // definitionKey == &quot;test_vehicle&quot;  
System.out.println(pd.getVersion()); // definitionVersion == &quot;1&quot;  
System.out.println(pd.getId());         // definitionId == &quot;test_vehicle-1&quot; 
&lt;/pre&gt;


&lt;p&gt;&lt;/p&gt;

&lt;p&gt;这在创建流程实例和查询流程定义的时候要特别注意：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
ExecutionService.startProcessInstanceById(“test_vehicle-1”);  
ExecutionService.startProcessInstanceByKey(“test_vehicle”);  
&lt;/pre&gt;


&lt;p&gt;startProcessInstanceById() 传的是 definitionId（不是 deploymentId），startProcessInstanceByKey() 传的是 definitionKey。查询的时候，还可以通过 definitionName 来查：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
RepositoryService.createProcessDefinitionQuery().processDefinitionName(&quot;test-vehicle&quot;); 
&lt;/pre&gt;


&lt;p&gt;在项目中有一个方法，是传入 definitionName 来创建实例，先 RepositoryService.createProcessDefinitionQuery().processDefinitionName(&quot;test-vehicle&quot;) 来确定时候有 processDefinition 存在，如果有，就 ExecutionService.startProcessInstanceByKey(&quot;test-vehicle&quot;)。结果就悲剧了。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/jbpm-4.3/2010/07/29/jbpm-4-3-process-hyphen-in-process-name-weirdly</link>
                <guid>http://erikyao.github.io/jbpm-4.3/2010/07/29/jbpm-4-3-process-hyphen-in-process-name-weirdly</guid>
                <pubDate>2010-07-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>jBPM-4.3 中 deploymentId 和definitionId 应该是一对一的关系</title>
                <description>&lt;p&gt;　　部署的时候，deploy() 返回的就是 deploymentId。deploymentId 虽然是个 String，不过仅包含数字，目前我还不清楚它的生成策略。&lt;/p&gt;

&lt;p&gt;　　每次部署，还会产生一个 definitionId。definitionId 的生成与 process.jpdl.xml 文件有关：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;  

&amp;lt;process name=&quot;ProcessName&quot; key=&quot;ProcessKey&quot;  version=&quot;1024&quot; xmlns=&quot;http://jbpm.org/4.3/jpdl&quot;&amp;gt;  
    ……  
&amp;lt;/process&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;definitionId == &lt;strong&gt;key-version&lt;/strong&gt;，如上面这个 jpdl，部署后生成的 definitionId 就是 &quot;ProcessKey-1024&quot;。不过要注意两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果没有写 &amp;lt;process key=&quot;xxx&quot;&amp;gt;，那么默认 key == name（特殊情况见 &lt;a href=&quot;/jbpm-4.3/2010/07/29/jbpm-4-3-process-hyphen-in-process-name-weirdly/&quot;&gt;jBPM-4.3 &amp;lt;process&amp;gt; 标签 name 属性中的短横线会变成下划线赋给 key 属性 &lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;如果写了 &amp;lt;process version=&quot;xxx&quot;&amp;gt;，那么这个 jpdl 只能部署一次，因为 version 指定了，key-version 就定死了。若不写 &amp;lt;process version=&quot;xxx&quot;&amp;lt;，可以把这个 jpdl 部署多次，且 jBPM 可以帮你实现 version 的自增1&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　deploymentId 和 definitionId 是可以互查的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
/** 根据deployId找definitionId */  
String definitionId = processEngine.getRepositoryService().createProcessDefinitionQuery().deploymentId(deployId).uniqueResult().getId(); 

/** 根据definitionId找deployId */  
String deployId = processEngine.getRepositoryService().createProcessDefinitionQuery().processDefinitionId(definitionId).uniqueResult().getDeploymentId();   
&lt;/pre&gt;


&lt;p&gt;　　单位项目的需求中，没有解释 deploymentId 的概念，全部用 definitionId 代替，好在是一对一的关系，不然就大条了……&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/jbpm-4.3/2010/07/29/deploymentid-and-definitionid-in-jbpm-4-3</link>
                <guid>http://erikyao.github.io/jbpm-4.3/2010/07/29/deploymentid-and-definitionid-in-jbpm-4-3</guid>
                <pubDate>2010-07-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring AOP 学习（二）：动态代理</title>
                <description>&lt;p&gt;　　如果系统中有 500 个类，每个类都要添加日志功能，此时无论是直接修改源代码、继承还是组合，都是十分巨大的工作量。此时 AOP 可以帮我们解决这个问题。&lt;/p&gt;

&lt;p&gt;　　现在假设记录日志的功能已经单独提出来了，由 LogInterceptor 来完成：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package com.bjsxt.aop;  
  
public class LogInterceptor {  
    public void beforeMethod() {  
        System.out.println(&quot;logging...&quot;);  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;有了 Spring AOP，我们就可以用配置文件来说明：“在某个类的每一个方法执行之前，都给我调用一次 beforeMethod() 方法”（更复杂一点的做法是给 beforeMethod() 方法添加一个 Method 参数，这样可以配置可以具体到某个类的某个方法上），如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;beans&amp;gt;  
    &amp;lt;bean id=&quot;u&quot; class=&quot;com.bjsxt.dao.impl.UserDAOImpl&quot; &amp;gt;  
        &amp;lt;!-- 非标准写法，仅作演示 --&amp;gt;  
        &amp;lt;Log class=&quot;com.bjsxt.aop.LogInterceptor&quot; logMethod=&quot;beforeMethod&quot; targetMethod=&quot;all&quot; /&amp;gt;  
    &amp;lt;/bean&amp;gt;  
&amp;lt;/beans&amp;gt;  
&lt;/pre&gt;


&lt;p&gt;这样，在配置文件中给 500 个 bean 都加上这么一段，就能给这 500 个类都加上日志功能了。&lt;/p&gt;

&lt;p&gt;　　那么 Spring AOP 是如何实现的呢？用的是动态代理的方法。&lt;/p&gt;

&lt;p&gt;　　参考 &lt;a href=&quot;/java/2009/08/13/proxy-parameter-of-the-invoke-method/&quot;&gt;the proxy parameter of the invoke() method&lt;/a&gt;，我们可以把 LogInterceptor 实现成一个 InvocationHandler:&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package com.bjsxt.aop;  
  
import java.lang.reflect.InvocationHandler;  
import java.lang.reflect.Method;  
  
public class LogInterceptor implements InvocationHandler {  
    private Object target;  
      
    public Object getTarget() {  
        return target;  
    }  
  
    public void setTarget(Object target) {  
        this.target = target;  
    }  
  
    public void beforeMethod(Method m) {  
        System.out.println(m.getName() + &quot;: logging...&quot;);  
    }  
  
    public Object invoke(Object proxy, Method m, Object[] args)　throws Throwable {  
        beforeMethod(m);  
        m.invoke(target, args);  
        return null;  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;调用的代码如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class AOPTest {  
    public static void main(String[] args) {  
        UserDAO userDAO = new UserDAOImpl();  
        LogInterceptor li = new LogInterceptor();  
        li.setTarget(userDAO);  
          
        UserDAO userDAOProxy = (UserDAO)Proxy.newProxyInstance(userDAO.getClass().getClassLoader(), userDAO.getClass().getInterfaces(), li);  
          
        userDAOProxy.save(new User());  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;这里要特殊说明的是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;userDAOProxy 对象是 UserDAOImpl 类的动态代理，userDAOProxy 是 &lt;em&gt;&lt;strong&gt;代理对象&lt;/strong&gt;&lt;/em&gt;，UserDAOImpl 对象是 &lt;em&gt;&lt;strong&gt;被代理对象&lt;/strong&gt;&lt;/em&gt;；&lt;/li&gt;
&lt;li&gt;若想用 Java API 来给某个类（如 UserDAOImpl）来创建动态代理，那么这个类必须实现一个接口（如 UserDAO），没有实现接口的类用 Java API 是无法创建动态代理的（但 cglib 可以）。所以在 Proxy.newProxyInstance() 方法中，需要把被代理类的接口，即 userDAO.getClass().getInterfaces() 传递进去。&lt;/li&gt;
&lt;li&gt;代理对象和被代理对象应该在同一个 classLoader 中，如果在不同的 classLoader 中，它们就无法互相访问，所以 userDAO.getClass().getClassLoader() 也作为参数传递给了 Proxy.newProxyInstance()。代理对象和被代理对象需要互相访问的原因见第4点&lt;/li&gt;
&lt;li&gt;我们得到的 userDAOProxy 对象，其类型应该是一个组合了 LogInterceptor 的类（li 作为参数被传递给了 Proxy.newProxyInstance()），而 LogInterceptor 又组合了 userDAOImpl（li.setTarget(userDAO)）；加上 userDAOProxy 又实现了 UserDAO 接口，所以 userDAOProxy 看上去应该是这样一个类：&lt;/li&gt;
&lt;/ol&gt;


&lt;pre class=&quot;prettyprint linenums&quot;&gt;
// 非标准写法，仅作演示用  
public class UserDAOProxy implements UserDAO {  
    private InvocationHandler invocationHandler;  
  
    public UserDAOProxy(InvocationHandler invocationHandler) {  
        super();  
        this.invocationHandler = invocationHandler;  
    }  
  
    public InvocationHandler getInvocationHandler() {  
        return invocationHandler;  
    }  
  
    public void save(User user) {  
        this.invocationHandler.invoke(this, UserDAO.class.getDeclaredMethod(&quot;save&quot;, User.class), user);  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;这样，Proxy.newProxyInstance(userDAO.getClass().getClassLoader(), userDAO.getClass().getInterfaces(), li) 也就相当于 new UserDAOProxy(li)。userDAOProxy 的 save() 方法的实际过程是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://eovqra.bn1.livefilestore.com/y2psdMa3VIkfLxJVKzL7OljPH8_04W32ozs_rNo70aCujoHjUlwauQag5x6AE7jPtVMrobEvNG0wvEJAIjGrXNL6EIkk78R0zG6dKwcNCcg4V8/251a2192-7c96-3baa-838c-5a0aef24de8e.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Spring AOP 为系统添加业务逻辑的动态代理方法大抵就是这样。&lt;/p&gt;

&lt;p&gt;　　如果 UserDAO 还有个 delete() 方法，那么 userDAOProxy.delete() 也会去调用 li.invoke(proxy, delete, user)。这就体现了 InvocationHandler 是 “对被代理对象的任意方法的 invocation 都 handle” 这么一个概念。&lt;/p&gt;

&lt;p&gt;　　当然，更好的实现是把 beforeMethod 这部分逻辑提出来，让 LogInterceptor 这个类侧重 “Interceptor” 而不包含 &quot;Log&quot; 的逻辑，beforeMethod 完全可以用一个 Logger 类来实现&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/aop/2010/07/28/learning-spring-aop-part-2-dynamic-proxy</link>
                <guid>http://erikyao.github.io/aop/2010/07/28/learning-spring-aop-part-2-dynamic-proxy</guid>
                <pubDate>2010-07-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring AOP 学习（一）：组合对比继承的优势</title>
                <description>&lt;p&gt;　　来自尚学堂Spring视频教程；作文字总结。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　系统中现有接口 UserDAO 及其实现 UseDAOImpl：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package com.bjsxt.dao;  
  
import com.bjsxt.model.User;  
  
public interface UserDAO {  
    public void save(User user);  
}  
&lt;/pre&gt;




&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package com.bjsxt.dao.impl;  
  
import com.bjsxt.dao.UserDAO;  
import com.bjsxt.model.User;  
  
public class UserDAOImpl implements UserDAO {  
    public void save(User user) {     
        // Hibernate or JDBC, whatever
        System.out.println(&quot;user saved!&quot;);  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;现在需要在save方法前记录日志，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package com.bjsxt.dao.impl;  
  
import com.bjsxt.dao.UserDAO;  
import com.bjsxt.model.User;  
  
public class UserDAOImpl implements UserDAO {  
    public void save(User user) {     
        // Hibernate or JDBC, whatever
        System.out.println(&quot;logging......&quot;);  
        System.out.println(&quot;user saved!&quot;);  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;当然，像这样直接在源代码里添加当然是最简单的了。但如果拿不到源代码呢？此时可以新写一个类来继承 UserDAOImpl，用 delegation：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package com.bjsxt.dao.impl;  
  
import com.bjsxt.model.User;  
  
public class UserDAOImpl2 extends UserDAOImpl {  
    public void save(User user) {  
        System.out.println(&quot;logging......&quot;);  
        super.save(user);     
    }  
}  
&lt;/pre&gt;


&lt;p&gt;用组合的方式也可以，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package com.bjsxt.dao.impl;  
  
import com.bjsxt.dao.UserDAO;  
import com.bjsxt.model.User;  
  
public class UserDAOImpl3 implements UserDAO {    
    private UserDAO userDAO = new UserDAOImpl();  
      
    public void save(User user) {     
        System.out.println(&quot;logging......&quot;);  
        userDAO.save(user);   
    }  
}  
&lt;/pre&gt;


&lt;p&gt;这样，把系统的 beans.xml 文件中配置的 UserDAOImpl 改成 UserDAOImpl2 或者 UserDAOImpl3，系统就有了记录日志的的功能了。&lt;/p&gt;

&lt;p&gt;　　这三种添加日志功能的方法中：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;直接在源码中写死是最不灵活的方式，因为万一要修改日志功能，要在 UserDAOImpl 的代码中去搜索日志功能的代码，耦合度太高&lt;/li&gt;
&lt;li&gt;继承的方式也不够灵活。首先 UserDAOImpl1 这个类无法再继承其他的类；再次，父类的改动必然引起子类的改动，耦合度太高&lt;/li&gt;
&lt;li&gt;组合没有耦合度太高的问题；成员 private UserDAO userDAO 可以使用多态；继承只能继承一个 Impl，而组合更为灵活，可以组合多个 Impl，如同时组合 UserDAOImpl 和 ForumDAOImpl。这3种方法中，组合的方式最好，在设计模式中也经常用组合来替代继承&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　另：这里的继承和组合都是静态代理，对应于 &lt;a href=&quot;/aop/2010/07/28/learning-spring-aop-part-2-dynamic-proxy/&quot;&gt;Spring AOP 学习（二）：动态代理&lt;/a&gt; 中的动态代理&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/aop/2010/07/28/learning-spring-aop-part-1-composition-over-inheritance</link>
                <guid>http://erikyao.github.io/aop/2010/07/28/learning-spring-aop-part-1-composition-over-inheritance</guid>
                <pubDate>2010-07-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Java 的值传递</title>
                <description>&lt;p&gt;　　所谓的值传递 (pass-by-value) 指的是：传递给方法的是参数值的一个 copy。Java 方法使用的永远是值传递 (很多地方说到的“引用传递”其实也可以看做是值传递，概念搞多了反而还不好理解，干脆说死一点，Java 就只使用值传递)。&lt;/p&gt;

&lt;p&gt;　　通过例子来看：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class Test {  
    public static void change(String s) {  
        s = &quot;changed&quot;;  
    }  
      
    public static void main(String[] args) {  
        String s = &quot;original&quot;;  
          
        change(s);  
        System.out.println(s); // Output: original  
    }  
}
&lt;/pre&gt;


&lt;p&gt;　　值传递的示意图如下：
　　&lt;img src=&quot;https://t7slng.bn1304.livefilestore.com/y2pPjUFFDM2GBAkNZP3obdL0cxcObiSclcwSV4VWenY2s1cV5oRFXTQJj-u4_MAWnzrvrkLIPJzlrpAj5TT0IcU6a7IOFz22Uc79UgVdmn2zp0/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　由于 String 是 immutable class，即：String 对象一旦创建，就不可修改。所以应该这么理解：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
String s = &quot;original&quot;; // String s = new String(&quot;original&quot;);
s = &quot;changed&quot;; // s = new String(&quot;changed&quot;);
&lt;/pre&gt;


&lt;p&gt;　　即 s = &quot;changed&quot; 并不是把 &quot;original&quot; 对象修改成 &quot;changed&quot;，而是新建了一个 &quot;changed&quot; 对象，而且于此同时 &quot;original&quot; 对象依然存在。亦即不应该看成下面这种表示：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
String s = new String(&quot;original&quot;);  
s.setValue(&quot;changed&quot;);  
&lt;/pre&gt;


&lt;p&gt;　　正因为 String 是个不可变类，所以在 change()方法中，参数 s 指向 &quot;original&quot;，而 s 的拷贝指向 &quot;changed&quot;，s 的拷贝的行为对 s 没有影响，所以 System.out.println(s) 还是打印出 &quot;original&quot;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　下面是一个StringBuffer的例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class Test {   
    public static void change(StringBuffer sb) {  
        sb.replace(0, sb.length(), &quot;changed&quot;);  
    }  
      
    public static void main(String[] args) {  
        StringBuffer sb = new StringBuffer(&quot;original&quot;);  
          
        change(sb);  
        System.out.println(sb.toString()); // Output: changed  
    }  
} 
&lt;/pre&gt;


&lt;p&gt;&lt;img src=&quot;https://hec1wq.bn1303.livefilestore.com/y2p6ZBcjv_rei2CCCfQNYu7bw85aVURnuxF8PPZfKeGK_BNe6b5J5zw9b-OJRTFYqDLOXnTrUqf4CCfZXNpb0aQmhPV2Y6RYxFLW-O73UTa4Ow/2.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;题外话&lt;/em&gt;：一般说来，String 和 primitive 都是 immutable class，而 StringBuffer、Date 还有数组都是可变类。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2010-7-6补充&lt;/em&gt;：用 final 来修饰方法的参数可以强制禁止参数的拷贝指向新的对象，例如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class Test {  
    public static void change(final String s) {  
        s = &quot;changed&quot;; // 非法！！！  
    }  
      
    public static void main(String[] args) {  
        String s = &quot;original&quot;;  
          
        change(s);  
        System.out.println(s);   
    }  
}
&lt;/pre&gt;


&lt;p&gt;这里 final 就可以禁止 copy of String s 指向新对象 &quot;changed&quot; 的行为。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011.10.23补充：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　对参数来说，可以分三类：(1)基本类型 primitive type；(2)可变类对象 reference；(3)不可变类对象 reference。(2)(3)的情况上面已经讨论过了，那么基本类型的情况如何呢？&lt;/p&gt;

&lt;p&gt;　　基本类型的情况有一点特殊。基本类型和 reference 都是在栈上的值，只是 reference 存的是堆上对象的地址值，而基本类型存的是本身的值。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://t7tbhw.bn1303.livefilestore.com/y2pAoCVZHcmBCj3Bkkl4bbxdguLdaZaX3dfHeZ3M6NcTrfgGh-CPC2ujnBt5jn20AK4ypRcqeoIms223TgfNLtvzdEQuOWsf1wcwUOwTh3OH5E/3.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　当 (i, j) 作为参数传入时，j 会被原样 copy 一份，这份 copy 仍然指向 Integer(10)；i 也会被原样 copy 一份，值仍然为 5。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hec1wq.bn1304.livefilestore.com/y2pwWGugzZOy0PCKjqUJbTnslFuIEYLjxBqHQGEztvXpNbDU10B3ngiNzyk0IDO8W_VWHCwdDrik5saHpMma_a4fIbDiZ4q0ChWIHZmJcCytSs/4.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　所以此时在方法里 i = xxx 或者 j = new Integer(xxx)，其实对 (i, j) 并没有什么影响：&lt;/p&gt;

&lt;p&gt;　　当方法执行完毕，堆栈内容和方法执行前没有变化。&lt;/p&gt;

&lt;p&gt;　　可以总结一下，java 的值传递是在栈上进行的，即将栈上的 primitive type 或是reference copy 一份，再传递给方法，方法实际操作的是这份 copy。这份 copy 能否影响到堆上的值，要看方法具体对 copy 的操作是啥，如果是 setter，那肯定改变了堆置，如果是 new，其实不会改变。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011.10.26补充：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　联系到&lt;code&gt;== 与 Object.equals() 的区别&lt;/code&gt;，我们是否可以认为：&lt;code&gt;== 比较的是栈上的两个值是否相等&lt;/code&gt;？&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2010/07/04/pass-by-value-in-java</link>
                <guid>http://erikyao.github.io/java/2010/07/04/pass-by-value-in-java</guid>
                <pubDate>2010-07-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>《jBPM-4.3 用户手册》第6章《jpdl》翻译稿</title>
                <description>&lt;p&gt;　　对照英文版做了翻译、补充和整理。&lt;/p&gt;

&lt;p&gt;　　对于原文档中的错误、翻译的用词或是其他要特别说明的地方，在本文中用“编者注”来说明。&lt;/p&gt;

&lt;p&gt;　　翻译拿不准的地方都附上了英文原文。&lt;/p&gt;

&lt;p&gt;　　TODO 表示尚有疑问的地方或是未来版本（if any, ^_^）需要改进的地方。&lt;/p&gt;

&lt;p&gt;　　文中每一个示例都标出了源代码的位置。&lt;/p&gt;

&lt;p&gt;　　本文只是用户手册中的第六章，不是全部的翻译。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Download ①: &lt;a href=&quot;https://eovctg.bn1.livefilestore.com/y2mesAhLwoyudW7LDSWz_Fkwiy9Lp7bU07Ax3MUURtclofKUAVEw4bIQArbmL4mj3GyKi-8jF_RgpRubyrkw97f5FJPkJ4dVjKqEtMB1-MleVs/jBPM-4.3-jpdl.docx?download&amp;amp;psid=1&quot;&gt;docx edition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Download ②: &lt;a href=&quot;https://eovctg.bn1301.livefilestore.com/y2m_-1dlbeUZBnIIgu_TwVGUORfS-NIXo3bZRFMNzd0kJu0ZKl7dZOolCEVqY4cUl3lM0TSdVksQlCd1X8yIp1jZ1wm77cPAbXexfaJuUSP_pg/jBPM-4.3-jpdl.pdf?download&amp;amp;psid=1&quot;&gt;pdf edition&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://erikyao.github.io/jbpm-4.3/2010/06/11/chs-edition-of-chapter-6-of-jbpm-4-3-user-manual</link>
                <guid>http://erikyao.github.io/jbpm-4.3/2010/06/11/chs-edition-of-chapter-6-of-jbpm-4-3-user-manual</guid>
                <pubDate>2010-06-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>org.apache.cxf.interceptor.Fault: Could not send Message</title>
                <description>&lt;p&gt;　　说明与esb服务器通讯不正常。&lt;/p&gt;

&lt;p&gt;　　检查点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在浏览器中查看 wsdl 是否发布成功&lt;/li&gt;
&lt;li&gt;检查 ESB 端口是否打开&lt;/li&gt;
&lt;li&gt;检查客户端调用的 endpoint 中 Address 是否有拼写错误&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　不是什么大问题，但第3种情况还真是遇到了，谨记。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/cxf/2010/05/27/org-apache-cxf-interceptor-fault-could-not-send-message</link>
                <guid>http://erikyao.github.io/cxf/2010/05/27/org-apache-cxf-interceptor-fault-could-not-send-message</guid>
                <pubDate>2010-05-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>UML 类图之关联、聚合、组合、依赖</title>
                <description>&lt;p&gt;　　一直没有搞清楚这几个概念，这里做总结。来自《大话设计模式》。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;1. 关联 (Association)&lt;/h2&gt;

&lt;p&gt;　　仅仅表示对象 A “知道” 对象 B，对象 A 并不 “拥有” 对象 B（这里的 “知道” 和 “拥有” 并不一定是从业务逻辑上判断，应该宽泛到从常识上判断）。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i44cqg.bn1.livefilestore.com/y2p-PdPPH2El-_xBSn2qFo3IaKs70Mvy4xMTsTqLdIsPRujfi7sp6aesR8FtEXmM9A6DhFjtLoyRgjA5ammwmTrBq4lA2Vu_ZM_Z9tObHr3sMc/association.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;企鹅 “知道” 气候，但并不 “拥有” 气候，在代码上反映为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Penguin extends Bird {  
    private Climate c;  
}  
&lt;/pre&gt;


&lt;hr /&gt;

&lt;h2&gt;2. 聚合 (Aggregation)&lt;/h2&gt;

&lt;p&gt;　　聚合在关联的基础上更近一步，表示一种弱 “拥有” 关系，对象 A 可以包含对象 B，对象 B 可以是对象 A 的一部分，但也可以不是（在代码上的表现是对象 B 为 null）。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i44cqg.bn1302.livefilestore.com/y2pg-PQCK_Eu48KFHL3QRFCsGXtmdCE0iG_lnvKvtkL1dJ1xuGdZ22toFAHSo7IxG1HROb8Rn243ZXruUdTxWcL6AXHWW7UzRrjWDdgThumrNQ/aggregation.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然雁群理所当然应该包含大雁，但也存在着 null 雁群，即 WildGoose 数组为空的情况。从代码上看：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class WildGooseGroup {  
    private arrayWildGoose WildGoose[];  
}  
&lt;/pre&gt;


&lt;p&gt;与关联并没有什么不同。的确是这样，关联和聚合的区别仅体现在这两个对象在业务逻辑或是在常识中的关系，在代码层次是没有区别的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;3. 组合 (Composition)&lt;/h2&gt;

&lt;p&gt;　　在聚合关系上更进一步，表示一种强 “拥有” 关系，对象 A 和对象 B 的生命周期一样，通俗说来就是 “同年同月同日生，同年同月同日死”。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i44cqg.bn1303.livefilestore.com/y2p0Za2GiOWmNidpJ19YNJU_6uu86nhRM7mU-hdJquc7p5A31Tuqfja6iJwuRZYXAkn-WXQTVQyLD3m0xktntJU3MLDmsEuqt18_vEPTM-j3oM/composition.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;鸟必然 “拥有” 翅膀，如果 Wing[2] 为空，那么这个这个 Bird 对象是不应该存在的。在代码上体现为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Bird extends Animal {  
    private wings Wing[2];  
      
    public Bird() {  
        wings[0] = new Wing();  
        wings[1] = new Wing();  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;可见Bird和Wing对象是强制绑定在一起的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;4. 依赖 (Dependency)&lt;/h2&gt;

&lt;p&gt;　　依赖表示一种 “需要” 的关系，但一般被依赖的对象 B 不是对象 A 的成员。如上图所示，鸟的新陈代谢需要氧气和水，但氧气和水都不会是鸟的成员。依赖和关联的区别大抵体现于此。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/design-pattern/2010/05/05/association-aggregation-composition-and-dependency</link>
                <guid>http://erikyao.github.io/design-pattern/2010/05/05/association-aggregation-composition-and-dependency</guid>
                <pubDate>2010-05-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Join</title>
                <description>&lt;p&gt;　　参考 &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;Join (SQL)&lt;/a&gt;，本文仅作总结。&lt;/p&gt;

&lt;p&gt;　　假设有两张表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ibmkqq.bn1304.livefilestore.com/y2pfn8d6av1Pei7fkRVkQ7lS4skNxvhnc7ZmVztUip4txhA22LjXQximkzD1pvs9TbhqlZn6zjRe5xIjfHaHf1ktL87lr8R-mHURAwpDAfGQaU/tables.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;1. Cross Join&lt;/h2&gt;

&lt;p&gt;　　即笛卡尔乘积 (Cartesian Product)。标准语法为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT *  
FROM   employee CROSS JOIN department;  
&lt;/pre&gt;


&lt;p&gt;也可以隐式地写为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT *  
FROM   employee, department;
&lt;/pre&gt;


&lt;p&gt;得到的表结构为 (LastName, DepartmentID, DepartmentID, DepartmentName)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;2. Inner Join&lt;/h2&gt;

&lt;p&gt;　　不标准地说，Inner Join 就是 Cross Join 加上了一个 where 子句，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT *    
FROM   employee, department   
WHERE  employee.DepartmentID = department.DepartmentID;  
&lt;/pre&gt;


&lt;p&gt;当然，这也是隐式的写法。标准语法为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT *  
FROM   employee INNER JOIN department   
ON     employee.DepartmentID = department.DepartmentID;  
&lt;/pre&gt;


&lt;h3&gt;2.1 Equi-Join&lt;/h3&gt;

&lt;p&gt;　　是 Inner Join 的特殊形式，特指 where 子句中的条件为 Equality Comparison，如上面的例子。不过它也有自己独特的语法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT *  
FROM   employee INNER JOIN department   
USING  (DepartmentID)  
&lt;/pre&gt;


&lt;p&gt;注意 using 子句会消除掉一个 DepartmentID 列，即得到 (LastName, DepartmentID, DepartmentName)，而不是 (LastName, DepartmentID, DepartmentID, DepartmentName)。可以把 using 子句看做是特殊的 where 子句。&lt;/p&gt;

&lt;h3&gt;2.2 Natural Join&lt;/h3&gt;

&lt;p&gt;　　是 Equi-Join 的特殊形式。Natural Join 不用指定 Equality Comparison 的 Column，它会自动查找做 Natural Join 的表中同名的 Column，隐式地在这个 Column 上使用 using 子句。它的标准语法为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT *  
FROM   employee NATURAL JOIN department;  
&lt;/pre&gt;


&lt;p&gt;如果有多个同名 Column (或者 Equi-Join 中 USING(Column1, ..., Column N))，则必须这多个 Column 都相等的列才被检入 Join 的结果中。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;3. Outer Join&lt;/h2&gt;

&lt;p&gt;　　Outer Join 的定义不太好描述，我们先来看看 Inner Join 的示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ibmkqq.bn1304.livefilestore.com/y2pXAXZXrfdPZGWeNzQclvP-2kIzIuIhIjx-0GpYq4K9lnKqdrSLtOenTtTiRG8o3JNkPojRboWru7Ti1rSm4uDttjbC8f9aqGvxQLFzbxfF7A/Inner%20Join.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于 (John, NULL) 和 (35, Marketing) 在对面表中没有匹配的记录，所以它们不会出现在 Inner Join 的结果中，而 Outer Join 就可以让这些没有匹配的记录出现在结果中。&lt;/p&gt;

&lt;h3&gt;3.1 Left Outer Join&lt;/h3&gt;

&lt;p&gt;　　指 “LEFT OUTER JOIN” 关键字左方的表中的记录都会出现在结果中，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT *    
FROM   employee  LEFT OUTER JOIN department    
ON     employee.DepartmentID = department.DepartmentID;
&lt;/pre&gt;


&lt;p&gt;得到的结果是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ibmkqq.bn1304.livefilestore.com/y2pcmzuH2-3_5IDotjDRgJeuQTsPx5vV2OefUQCNl8LXVf0Nz6qdmaRFL_Jskeo5NEMtyFy48e10hZ5LkFer1Qki8S7AcsT22ImLozsWXXPXfs/Left%20Outer%20Join%201.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;示意图为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ibmkqq.bn1301.livefilestore.com/y2pAN1e146OBMOvjDzTyWrdmpw5WyC2Q7T2n61gMhHXyEuzAHzfz5LIqGIxQQBdq3xfz-NiEZDItEZsB-PsqbHomhYmOT-RztimF_ZYOECfxc8/Left%20Outer%20Join%202.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;3.2 Right Outer Join&lt;/h3&gt;

&lt;p&gt;　　指 “RIGHT OUTER JOIN” 关键字右方的表中的记录都会出现在结果中，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT *   
FROM   employee RIGHT OUTER JOIN department   
ON     employee.DepartmentID = department.DepartmentID;
&lt;/pre&gt;


&lt;p&gt;得到的结果是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ibmkqq.bn1302.livefilestore.com/y2pcX-upqfQJII6wSQhc5y3kkbkBvp0Dio-d6DHnA5oK1l1Lk4GIuMjoGjLjTvlkyrzFEHpUy3l5VW1t3ASdzyCzVpbSt5pk77wZUKZ8mqgobI/Right%20Outer%20Join%201.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;示意图为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ibmkqq.bn1.livefilestore.com/y2ptKZ4pQ1FMZ-jd2YLqZP-esk_QSjCSjp8V4hzzbtd-IOaYqVcBxk9ON21Kg3lEGtsbp8hA2lbshHBRLmNEG4AJDxiwjsGAjUrdOUoRrnGkGI/Right%20Outer%20Join%202.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;3.3 Full Outer Join&lt;/h3&gt;

&lt;p&gt;　　全外联结，即左外联结和右外联结的综合 (并集)。如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT *    
FROM   employee FULL OUTER JOIN department   
ON     employee.DepartmentID = department.DepartmentID;  
&lt;/pre&gt;


&lt;p&gt;得到的结果是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ibmkqq.bn1.livefilestore.com/y2pVpxpTR605YqNDrKQknXiadTF0mx1uFlCEG7zsxr73ElnjbuFrELcWHnAyJIUnoMvQAkAazSW9jw4zjX6DzoHFiilMYiVKbocE0wEhMCe2Qs/Full%20Outer%20Join.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;4. Self Join&lt;/h2&gt;

&lt;p&gt;　　指表与自身的联结。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/sql/2010/04/03/sql-join</link>
                <guid>http://erikyao.github.io/sql/2010/04/03/sql-join</guid>
                <pubDate>2010-04-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>CruiseControl with Clover: the Configuration Guide</title>
                <description>&lt;ul&gt;
&lt;li&gt;Download ①: &lt;a href=&quot;https://wxfjyw.bn1302.livefilestore.com/y2msHQFqnQkWzqJLAouqHJGZDPVQy1YoT2Z4DrIqJdDsYFyjeOMELjiZeivg_Lu29AVg_uigKwvade3FvRC_owMpK2UFXAKF6ZcSa050jQ0UoE/CruiseControl_with_Clover_the_Configuration_Guide_v0.1.docx?download&amp;amp;psid=1&quot;&gt;docx edition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Download ②: &lt;a href=&quot;https://wxdrhw.bn1303.livefilestore.com/y2mZ3D4dM2Zkfavdjo0q_dlN3vDo3PD3KNsO9tf9N5OUe6XTfNKZrLAduzjI2ETF6m-_TI3TTOg5sYxuwDG4gn3N14JAvWSYURNcJwBu186840/CruiseControl_with_Clover_the_Configuration_Guide_v0.1.pdf?download&amp;amp;psid=1&quot;&gt;pdf edition&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://erikyao.github.io/continuous-integration/2010/03/30/cruisecontrol-with-clover-the-configuration-guide</link>
                <guid>http://erikyao.github.io/continuous-integration/2010/03/30/cruisecontrol-with-clover-the-configuration-guide</guid>
                <pubDate>2010-03-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Ant 中的 fork="true"</title>
                <description>&lt;p&gt;　　Set &lt;em&gt;fork&lt;/em&gt; attribute to true, to run javac in a separate process with its own heap size settings. If &lt;em&gt;fork&lt;/em&gt; is set to false, or not set (default is false), javac will run in the same process as Ant, which has a default maximum heap size.&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/ant/2010/03/04/fork-in-ant</link>
                <guid>http://erikyao.github.io/ant/2010/03/04/fork-in-ant</guid>
                <pubDate>2010-03-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Ant 路径之 **</title>
                <description>

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;fileset dir=&quot;${lib.dir}&quot; includes=&quot;*.jar&quot;/&amp;gt;&gt;  
&lt;/pre&gt;


&lt;p&gt;　　表示 include ${lib.dir} 文件夹 (不包括其子文件夹) 下的所有 .jar 文件&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;fileset dir=&quot;${lib.dir}&quot; includes=&quot;**/*.jar&quot;/&amp;gt;&gt;  
&lt;/pre&gt;


&lt;p&gt;　　表示的是 include ${lib.dir} 及其子文件夹下的所有 .jar 文件&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/ant/2010/03/02/wildcard-in-ants-include</link>
                <guid>http://erikyao.github.io/ant/2010/03/02/wildcard-in-ants-include</guid>
                <pubDate>2010-03-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>clover 测试 servlet，提示找不到类 com_cenqua_clover/CoverageRecorder 的解决方法</title>
                <description>&lt;p&gt;　　使用 clover-for-eclipse 时，发现测试一个简单的 Dynamic Web Project 时，servlet 总是显示不出来，提示找不到类 com_cenqua_clover/CoverageRecorder。&lt;/p&gt;

&lt;p&gt;　　解决办法一：下载一个 clover-for-ant，把 lib 里的 clover.jar 放到项目的 lib 下即可。&lt;/p&gt;

&lt;p&gt;　　解决方法二：由 &lt;a href=&quot;http://sunnylocus.iteye.com/&quot;&gt;sunnylocus&lt;/a&gt; 提供：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;不用这么复杂，Run -&gt;Run Configurations 选择你运行此 servlet 的 web 容器，点选 classpath 选项卡，在 User Entries 加 CLOVER_RUNTIME 环境变量&lt;/p&gt;&lt;/blockquote&gt;
</description>
                <link>http://erikyao.github.io/continuous-integration/2010/02/23/coveragerecorder-problem</link>
                <guid>http://erikyao.github.io/continuous-integration/2010/02/23/coveragerecorder-problem</guid>
                <pubDate>2010-02-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>简单 SQL 语句的逻辑顺序</title>
                <description>&lt;p&gt;　　考虑一个简单的语句：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
SELECT order_num, SUM(quantity * item_price) AS ordertotal  
FROM orderitems  
WHERE quantity &gt; 1  
GROUP BY order_num  
HAVING ordertotal &gt;= 50  
ORDER BY ordertotal; 
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;FROM 确定所操作的表

&lt;ul&gt;
&lt;li&gt;WHERE 作行过滤 (row filtering)，过滤掉不符合条件的行

&lt;ul&gt;
&lt;li&gt;将过滤后的表按 GROUP BY 分组

&lt;ul&gt;
&lt;li&gt;HAVING 作分组过滤 (group filtering)，过滤掉不符合条件的分组

&lt;ul&gt;
&lt;li&gt;在过滤后的分组上作 SELECT 操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;ORDER BY 在何时执行并不重要，它只是保证最后的结果是排序显示的。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/sql/2009/12/26/simple-example-of-sql-logic</link>
                <guid>http://erikyao.github.io/sql/2009/12/26/simple-example-of-sql-logic</guid>
                <pubDate>2009-12-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>MySQL REGEXP</title>
                <description>&lt;p&gt;　　参考 &lt;a href=&quot;http://www.zytrax.com/tech/web/regex.htm&quot;&gt;Regular Expressions - User Guide&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;1. 关于 [ ] 和 { }&lt;/h2&gt;

&lt;p&gt;　　[ ] 表示在 [ ] 所在的位置匹配一个 (only one) 字符，该字符的范围由 [ ] 内的内容指定。&lt;/p&gt;

&lt;p&gt;　　在使用 [:digit:] 这类的 Character Class 时需注意，[:digit:] 只相当于0-9，[[:digit:]] 才相当于[0-9]。&lt;a href=&quot;http://bugs.mysql.com/bug.php?id=22568&quot;&gt;单独使用 [:digit:] 是要出问题的&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　{ } 用来指定匹配字符数，[ ] 默认地相当 [ ]{1}&lt;/p&gt;

&lt;p&gt;　　{ } 这类的 Iteration Metacharacter 的指定对象为 { } 之前的单个字符或 ( )，比如 abc{2} --&gt;abcc，(abc){2} --&gt;abcabc&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;2. Positioning Metacharacters (Anchor)&lt;/h2&gt;

&lt;p&gt;　　^ 文本开始，$ 文本结尾，[[:&amp;lt;:]] 单词开头，[[:&gt;:]] 单词结尾。作用范围是其前或其后的单个字符或是 ( )。注意它们出现的位置。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
-- 匹配一个以&quot;x&quot;开头、以&quot;x&quot;结尾的字符串  
SELECT &#39;x word x&#39; REGEXP &#39;^x[[:print:]]*x$&#39;; -- 1  
-- 匹配一个以&quot;x w&quot;开头、以&quot;d x&quot;结尾的字符串  
SELECT &#39;x word x&#39; REGEXP &#39;^(x w)[[:print:]]*(d x)$&#39;; -- 1  
-- 匹配一个包含以&quot;w&quot;开头的、以&quot;d&quot;结尾的单词的字符串  
SELECT &#39;x word x&#39; REGEXP &#39;[[:&lt;:]]w[[:print:]]*d[[:&gt;:]]&#39;; -- 1  
-- 匹配一个包含以&quot;wo&quot;开头的、以&quot;rd&quot;结尾的单词的字符串  
SELECT &#39;x word x&#39; REGEXP &#39;[[:&lt;:]](wo)[[:print:]]*(rd)[[:&gt;:]]&#39;; -- 1    
&lt;/pre&gt;


&lt;p&gt;不过这里用 ( ) 和不用 ( ) 貌似没有什么区别…&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/mysql/2009/12/25/mysql-regexp</link>
                <guid>http://erikyao.github.io/mysql/2009/12/25/mysql-regexp</guid>
                <pubDate>2009-12-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Isolation</title>
                <description>&lt;p&gt;　　参考 &lt;a href=&quot;http://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Read_phenomena&quot;&gt;Isolation (database systems)&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　Isolation 的理想状态是：the result of Transaction A is invisible to Transaction B until Transaction A is completed。不过这么一来，只有 Serializable 级别才能满足要求，即 Transactions 是一个接一个地执行，不允许 Transactions 的并行。如果想要 Transactions 的并行，那么就不可能有绝对的 Isolation。为此，ANSI/ISO 制定的 SQL 标准给 Isolation 分了4个级别，由高到低分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Serializable&lt;/li&gt;
&lt;li&gt;Repeatable Read (Phantom Read)&lt;/li&gt;
&lt;li&gt;Read Committed (Nonrepeatable Read)&lt;/li&gt;
&lt;li&gt;Read Uncommitted (Dirty Read)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;级别越高的，isolation 性越好，而低级别的 isolation 会有各种各样的并发问题 (如上面括号中所示)。下面一一介绍。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;1. Read Uncommitted&lt;/h2&gt;

&lt;p&gt;　　Transaction 1 可以查看 Transaction 2 未提交的操作结果，这会导致 Dirty Read 的问题，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wxet4g.bn1302.livefilestore.com/y2pBrwlTJ9uhagsjWMFovD3FqiRnGNUO7_w0DmTHmTc7JZHIloJMJTvd8TJXcalHACGhNJRF3AjTym7GnDVU7SLFJ2rXn11L89lobfDgB1_Yi0/Dirty%20Read.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Transaction 1 的执行的第二个 query 会读到 Transaction 2 中 update 的结果，如果 Transaction 2 rollback 的话，这个读到的数据明显是错误的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;2. Read Committed&lt;/h2&gt;

&lt;p&gt;　　如果我们强制 Transaction 1 只能读 Transaction 2 中已经 commit 的 update，就可以解决 Dirty Read 的问题。强制的手段是：每次 query（比如SELECT）时，都会获取当前数据库（或者可能只是 query 涉及的表）的一个 snapshot，query 从这个 snapshot中获得结果。没有 commit 的 update 不会在 snapshot 中出现，所以就不会被 query 到。&lt;/p&gt;

&lt;p&gt;　　这样允许 Transaction 2 并行执行，且不会影响 Transaction 1。当 Transaction 1 commit 的时候，DBMS 检测是否有冲突（比如 Transaction 1 也 update 了 Transaction 2 中 update 的 row），如果执行的结果等同于顺序执行 Transaction 1 和 Transaction 2，则认为没有冲突。&lt;/p&gt;

&lt;p&gt;　　但这样也会有问题：Nonrepeatable Read，即可能执行同一 query 两次而出现不同的结果，我们认为这是不符合一致性原则的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wxet4g.bn1304.livefilestore.com/y2pfwcDEtpnU8LvpUEND715nFyYMdwl89f0hLw680o2Y2TnIrPGbU2BGKdX19Ls5HrD5_mN44V-N040j5LHTFO1YIzqAn2aXQIgJ641jN9uyo0/Nonrepeatable%20Read.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;3. Repeatable Read&lt;/h2&gt;

&lt;p&gt;　　解决 Nonrepeatable Read 问题的办法是给 Transaction 1 中 SELECT 涉及的行加一个 read lock。&lt;/p&gt;

&lt;p&gt;　　锁的排斥功能很明确：read locks 不会 block read locks，只 block write locks；write locks block both read locks and write locks。&lt;/p&gt;

&lt;p&gt;　　不过会有新的问题：Phantom Read。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wxet4g.bn1303.livefilestore.com/y2putLwKZX0iBoFmYG3g4zfmnSNHhle7OjndVNGY2PQ19u5fZQjdtbiLtwbztcbrgSbcWON3ydC5Zt3y0-ICYYEBwPbeHpQFSDi-yp2YQXD4jY/Phantom%20Read.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当 Transaction 1 执行一个 range query（范围查询，如 like, between 等）时，只会为涉及到的 row 加 read lock，如果插入一个新 row 在 range 之内，第二次 range query 还是会被读出。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;4. Serializable&lt;/h2&gt;

&lt;p&gt;　　强制 Transactions 按顺序执行，所以 Transaction 之间不可能冲突。强制的手段是 place a read lock on every row the transaction read；同时，如果有 range query，还会添加一个 range lock。明显，Serializable 会耗费很多的 lock overhead。&lt;/p&gt;

&lt;p&gt;　　Serializable 相当于在 Transaction 1 开始时（而不是 query 开始时）给当前数据库（或是 Transaction 涉及的表）take a snapshot，Transaction 1 中的所有 query 都从这一个 snapshot 中获取结果。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/database/2009/12/25/isolation</link>
                <guid>http://erikyao.github.io/database/2009/12/25/isolation</guid>
                <pubDate>2009-12-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Simple Form Handling Example</title>
                <description>&lt;p&gt;　　继续 &lt;a href=&quot;/springmvc/2009/11/29/spring-mvc-example-anatomy/&quot;&gt;Spring MVC example anatomy&lt;/a&gt; 中springapp的例子。&lt;/p&gt;

&lt;p&gt;　　PriceIncreaseController extends SimpleFormController。SimpleFormController 有2个视图：formView 用来显示 form，successView 则是 form 提交后转到的页面。&lt;/p&gt;

&lt;p&gt;　　当我们从hello.htm(实际是hello.jsp)上点击priceincrease.htm的超链接时，实际是发送了一个GET方法的请求，然后处理流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vgk9nq.bn1301.livefilestore.com/y2patK-yYFT1JWrgQxzD4EBfbRYeTdUTN3lNj55sUpUe47nOdHntmFbF0GGqBKGAeP5MG5IKK6LAXzZ5IOKf4p6rmiCIldN77eDe4rvJyyvq1o/1.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　如果priceincrease.jsp页面上需要显示一些数据，可以通过formBackingObject()方法来初始化Command Object，这个接下来再讲。&lt;/p&gt;

&lt;p&gt;　　一般使用 DI 来设置 SimpleFormController 的 formView 和 successView：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;bean name=&quot;/priceincrease.htm&quot; class=&quot;springapp.web.PriceIncreaseFormController&quot;&amp;gt;  
    &amp;lt;property name=&quot;sessionForm&quot; value=&quot;true&quot; /&amp;gt;  
    &amp;lt;property name=&quot;commandName&quot; value=&quot;priceIncrease&quot; /&amp;gt;  
    &amp;lt;property name=&quot;commandClass&quot; value=&quot;springapp.service.PriceIncrease&quot; /&amp;gt;  
    &amp;lt;property name=&quot;validator&quot;&amp;gt;  
        &amp;lt;bean class=&quot;springapp.service.PriceIncreaseValidator&quot; /&amp;gt;  
    &amp;lt;/property&amp;gt;  
    &amp;lt;property name=&quot;formView&quot; value=&quot;priceincrease&quot; /&amp;gt;  
    &amp;lt;property name=&quot;successView&quot; value=&quot;hello.htm&quot; /&amp;gt;  
    &amp;lt;property name=&quot;productManager&quot; ref=&quot;productManager&quot; /&amp;gt;  
&amp;lt;/bean&amp;gt;  
&lt;/pre&gt;


&lt;p&gt;　　这里还有个有意思的事情：即使不配置formView，根据 &lt;a href=&quot;http://docs.spring.io/spring/docs/2.5.6/reference/mvc.html#mvc-coc&quot;&gt;惯例优先原则&lt;/a&gt;，DispatchServlet 还是能找到 priceincrease 这个 viewName，然后去交给 InternalResourceViewResolver 解析 (如果配置了，应该是 SimpleFormController 执行 showForm 操作，返回一个 new ModelAndView(formView) 给 DispatchServlet)&lt;/p&gt;

&lt;p&gt;　　我们注意到这里有 commandClass 和 commandName，这个还是相当于 jsp 页面的 Attribute。整个的提交的处理流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vgk9nq.bn1303.livefilestore.com/y2pBqhXu3IfpA39w6tXqjjL7-yKmlBoA9tDfLaDeK0Quye8CDjRkVQujsDWy4CQPixDvI-511juiJgYCTac1M4qvqmK9rT4P0e3IbiIp1XrXEU/2.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这里需要注意的有以下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Command Object 不需要名字。commandName 并不是 Command Object 的名字，所以在 formBackingObject() 方法里面创建 Command Object 不需要特别注意名字。formBackingObject() 是一个覆写方法，父类中的方法应该也只是简单地 new 一个 Command Object&lt;/li&gt;
&lt;li&gt;Command Object 的属性、JSP 中 &amp;lt;form&amp;gt; 标签中的 “path”、和 Validator 中的 reject 方法的参数存在对应关系，如下图所示 (文字描述太复杂了，画图算了)：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; &lt;img src=&quot;https://vgk9nq.bn1.livefilestore.com/y2pG9gagUKiA4NcNi-gqmSLmgtmRJYYQEknWtsMBaswEMhp-ebqkcj8oaBenuhorSQGtTkku7y7pjFt7hGiqrNTCe9BaqgCtbFcMVu0dHEJW38/3.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;lt;form:input path=&quot;percentage&quot;&amp;gt; 表示把这个文本框的输入内容写入 Command Object (已通过 commandName=“priceIncrease” 指定)；而 &amp;lt;form:error path=&quot;percentage&quot;&amp;gt; 会被展开为成一个 &amp;lt;span&amp;gt; 来显示错误信息 (if any)，详见 &lt;a href=&quot;http://docs.spring.io/spring/docs/2.5.0/reference/mvc.html#mvc-formtaglib-errorstag&quot;&gt;The errors tag&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://erikyao.github.io/springmvc/2009/12/11/simple-form-handling-example</link>
                <guid>http://erikyao.github.io/springmvc/2009/12/11/simple-form-handling-example</guid>
                <pubDate>2009-12-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Pointer Swizzling</title>
                <description>&lt;p&gt;　　swizzle 本来的用法应该是 to swizzle a beverage with a spoon，基本就是 &quot;搅动&quot; 的意思。pointer swizzling 有的翻译叫 “指针混写”，第一眼看上去简直不知所云。&lt;/p&gt;

&lt;p&gt;　　以下来自 Jargon File：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;To convert external names, array indices, or references within a data structure into address pointers when the data structure is brought into main memory from external storage; this may be done for speed in chasing references or to simplify code (e.g., by turning lots of name lookups into pointer dereferences). The converse operation is sometimes termed ‘unswizzling&#39;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　Jargon File 的这一段解释得还是不怎么清楚，看 Wikipedia 上的这个例子就很清楚了：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In computer science, pointer swizzling is the conversion of references based on name or position to direct pointer references. It is typically performed during the deserialization (loading) of a relocatable object from disk, such as an executable file or pointer-based data structure. The reverse operation, replacing pointers with position-independent symbols or positions, is sometimes referred to as unswizzling, and is performed during serialization(saving).&lt;br/&gt;
&lt;br/&gt;
For example, suppose we have the following linked list data structure:&lt;br/&gt;
&lt;br/&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
  struct node {&lt;br/&gt;
      int data;&lt;br/&gt;
      struct node *next;&lt;br/&gt;
  };&lt;br/&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;We can easily create a linked list data structure in memory using such an object, but when we attempt to save it to disk we run into trouble. Directly saving the pointer values won&#39;t work on most architectures, because the next time we load it the memory positions the nodes now use may be in use by other data. One way of dealing with this is to assign a unique id number to each node and then unswizzle the pointers by turning them into a field indicating the id number of the next node:&lt;br/&gt;
&lt;br/&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
struct node_saved {&lt;br/&gt;
  int data;&lt;br/&gt;
  int id_number;&lt;br/&gt;
  int id_number_of_next_node;&lt;br/&gt;
};&lt;br/&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;We can save these records to disk in any order, and no information will be lost. Other options include saving the file offset of the next node or a number indicating its position in the sequence of saved records.&lt;br/&gt;
&lt;br/&gt;
When we go to load these nodes, however, we quickly discover that attempting to find a node based on its number is cumbersome and inefficient. We&#39;d like our original data structure back so we can simply follow next pointers to traverse the list. To do this, we perform pointer swizzling, finding the address of each node and turning the &lt;em&gt;id_number_of_next_node&lt;/em&gt; fields back into direct pointers to the right node.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　简单地说来，就是内存中的节点间通过“逻辑”指针（实质是内存地址）连接，而将这些节点保存到磁盘时，“逻辑”指针就没有任何意义了，需要变换一种方式来表示这些节点间的连接关系（这里也不好叫做“物理”指针……），这个变换的过程称为 unswizzling。反过来，将这些节点从磁盘 load 到内存中时的变换就是 swizzling。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/os/2009/12/05/pointer-swizzling</link>
                <guid>http://erikyao.github.io/os/2009/12/05/pointer-swizzling</guid>
                <pubDate>2009-12-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>page（页面）</title>
                <description>&lt;p&gt;　　以下来自百度百科和Wikipedia。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　内存在计算机中的作用很大，电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致内存消耗殆尽。&lt;/p&gt;

&lt;p&gt;　　为了解决这个问题，Windows 中运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，以缓解内存的紧张。不过虚拟内存只是暂时存储物理内存的内容，任何使用中的内存都只能从物理内存中读取。&lt;/p&gt;

&lt;p&gt;　　充当虚拟内存的这部分硬盘空间即是页面文件，具体说来就是 XP 系统下的 pagefile.sys 这个文件。&lt;/p&gt;

&lt;p&gt;　　页面文件的组成单位为页面。&lt;/p&gt;

&lt;p&gt;　　In a context of computer virtual memory, a page, memory page, or virtual page is a fixed-length block of main memory (actually copy of main memory), that is contiguous in both physical memory addressing and virtual memory addressing. A page is usually a smallest unit of data for the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;memory allocation performed by the operating system for a program&lt;/li&gt;
&lt;li&gt;transfer between main memory and any other auxiliary store, such as hard disk drive&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　所以一个页面的大小应该和磁盘块大小一样，为 4KB。&lt;/p&gt;

&lt;p&gt;　　查看本机页面大小可以用下列程序：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
#include &lt;stdio.h&gt;  
#include &lt;windows.h&gt;  
   
int main(void)   
{  
    SYSTEM_INFO si;  
    GetSystemInfo(&amp;si);  
   
    printf(&quot;The page size for this system is %u bytes.\n&quot;, si.dwPageSize);  
   
    return 0;  
}  
&lt;/pre&gt;


&lt;p&gt;　　页面文件大小 ÷ 页面大小 = 页面数。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/os/2009/12/04/page</link>
                <guid>http://erikyao.github.io/os/2009/12/04/page</guid>
                <pubDate>2009-12-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Disk Drive（磁盘驱动器）</title>
                <description>&lt;p&gt;　　继续补课。来自wikipedia。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　一个 disk drive 包括两个移动部件：disk assembly (磁盘组合) 和 head assembly (磁头组合)。disk assembly 是盘片 (platter) 的集合，一个盘片有2个盘面 (side)。head assembly 是磁头 (head) 的集合，一个盘面一个磁头。&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;https://vgk2vg.bn1304.livefilestore.com/y2pcZkp4B-hvor1MJnDCagnhrSWWl2ay-76yeTVbCMk6xhVH_XrO6RBjshIosKTP4L1K2r2DnyP1YVGj7APuxnTQEFWANVzVIng-jKUZJuq_ow/disk%20driver.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;(1) Tracks (磁道)&lt;/h2&gt;

&lt;p&gt;　　The tracks are the thin concentric circular strips on a floppy medium or platter surface which actually contain the magnetic regions of data written to a disk drive.&lt;/p&gt;

&lt;p&gt;　　磁道是单个盘片上的同心圆环。&lt;/p&gt;

&lt;h2&gt;(2) Sectors (扇区)&lt;/h2&gt;

&lt;p&gt;　　一个磁道可以分成多个扇区。如果把磁道比作单个盘片上的同心圆环的话，那么扇区就是这个圆环上的一个扇面。&lt;/p&gt;

&lt;p&gt;　　扇区之间通过间隔 (gap) 隔开，gap 不能用来记录数据。gap 大概占整个 track 的10%&lt;/p&gt;

&lt;p&gt;　　可以简单地认为扇区的分布是均匀的，如下图所示，这时每个磁道的扇区数相等。不过这么一来不同磁道上的扇区面积不等，若要求每个扇区保存的数据容量相同的话，那么不同磁道上扇区的数据密度就会相差非常大。所以一般的做法是内圈 (比如内1/3) 磁道的扇区数最少，中圈 (比如中1/3) 的稍多，外圈 (比如外1/3) 的磁道数最多。&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;https://vgk2vg.bn1302.livefilestore.com/y2pqUIUhRIaWORIjlsFIRIF-KXLDafc23FhcUKRjlopY5AuBsvJWTS7oeVHVMfMnihGiwSwvn_5MLvWwvZjjUzIxpKKNE2iRMiDNmFcCc4OhkA/sector.gif?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;(3) Cylinder (柱面)&lt;/h2&gt;

&lt;p&gt;　　Cylinders are vertically formed by tracks. In other words, track 12 on platter 0 plus track 12 on platter 1 etc. is cylinder 12. The number of cylinders of a disk drive exactly equals the number of tracks on a single surface in the drive.&lt;/p&gt;

&lt;p&gt;　　柱面这个概念的提出可能是因为磁头组合的运动是 “同手同脚”，n 个磁头是共同进退。要将磁头 h 定位到盘片 s 上的磁道 t 中的扇区 c，首先是磁头组合运动到柱面 t  (柱面 t 即是所有盘片的磁道 t 的集合)，然后选择盘片 s 的磁头 h，转动盘片 s 使磁头 h 到达扇区 c 上方，然后磁头 h 开始读写扇区c。&lt;/p&gt;

&lt;p&gt;　　(柱面#, 盘片#, 扇区#) 唯一确定一块扇区，相当于 (盘片#, 磁道#, 扇区#) 唯一确定一块扇区，因为 柱面# == 磁道#。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/hardware/2009/12/04/disk-driver</link>
                <guid>http://erikyao.github.io/hardware/2009/12/04/disk-driver</guid>
                <pubDate>2009-12-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Spring MVC example anatomy</title>
                <description>&lt;p&gt;　　例子来自 &lt;a href=&quot;http://docs.spring.io/docs/Spring-MVC-step-by-step/&quot;&gt;Developing a Spring Framework MVC application step-by-step&lt;/a&gt; ，版本是 spring-framework-2.5.6.SEC01&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://vglspw.bn1302.livefilestore.com/y2pOqlFuqZyXLFlJfv0gXblKqxagQbcr7q7m0Ok6K3IrlR5ASHfxU8KdC4B4SbgdqbGQ7FBWXvm_oPdllMV58coth-82QQ37kv7lwqXng5L-_o/e52c303a-e30c-34e1-a55a-b707d881a99a.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;1. DispatchServlet 接过浏览器的 /hello.htm请求&lt;/h2&gt;

&lt;p&gt;　　在 springapp/war/WEB-INF/web.xml 中，定义了homepage：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;welcome-file-list&amp;gt;
    &amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt;
&amp;lt;/welcome-file-list&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以 http://localhost:8080/springapp 即相当于 http://localhost:8080/springapp/index.jsp。&lt;/p&gt;

&lt;p&gt;　　而 springapp/war/index.jsp 是直接 sendRedirect：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;%-- Redirected because we can&#39;t set the welcome page to a virtual URL. --%&amp;gt;
&amp;lt;c:redirect url=&quot;/hello.htm&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以又转到 http://localhost:8080/springapp/hello.htm&lt;/p&gt;

&lt;p&gt;　　在 springapp/war/WEB-INF/web.xml 中有：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;servlet&amp;gt;  
    &amp;lt;servlet-name&amp;gt;springapp&amp;lt;/servlet-name&amp;gt;  
    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;  
&amp;lt;/servlet&amp;gt;  
  
&amp;lt;servlet-mapping&amp;gt;  
    &amp;lt;servlet-name&amp;gt;springapp&amp;lt;/servlet-name&amp;gt;  
    &amp;lt;url-pattern&amp;gt;*.htm&amp;lt;/url-pattern&amp;gt;  
&amp;lt;/servlet-mapping&amp;gt;
&lt;/pre&gt;


&lt;p&gt;所以这个 http://localhost:8080/springapp/hello.htm 请求由 DispatcherServlet 来处理。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;2. DispatchServlet 确定 mapping of &amp;lt;Request, Controller&gt;&lt;/h2&gt;

&lt;p&gt;　　DispatchServlet 默认使用的是 BeanNameUrlHandlerMapping，即通过 controller 的 bean name 来与 request 对应。&lt;/p&gt;

&lt;p&gt;　　Controller 在 WebApplicationContext 文件中定义，而 WebApplicationContext 文件的命名规则是 &amp;lt;servlet-name&amp;gt;-servlet.xml，所以本案例的 WebApplicationContext 文件即是 springapp-servlet.xml。&lt;/p&gt;

&lt;p&gt;　　bean name 必须是 slash 开头，然后只能写 request 中最后一个 slash 后面的部分。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;bean name=&quot;/hello.htm&quot; class=&quot;springapp.web.InventoryController&quot;&amp;gt;  
    &amp;lt;property xxx=&quot;zzz&quot;&amp;gt;&amp;lt;/property&amp;gt;  
&amp;lt;/bean&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　另外还有 SimpleUrlHandlerMapping、ControllerClassNameHandlerMapping 和 CommonsPathMapHandlerMapping 三种 mapping 形式，这里就不展开了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;3. Controller 返回 ModelAndView 给 DispatchServlet&lt;/h2&gt;

&lt;p&gt;　　Controller 的类型有很多，最简单的形式就是自己实现一个 Controller 接口 (spring 自带了很多 Controller 及其子接口的实现)，只需实现一个 handleRequest(HttpServletRequest, HttpServletResponse) 方法，返回一个 ModelAndView 即可。&lt;/p&gt;

&lt;p&gt;　　ModelAndView(viewName, modelName, modelObject)，其中的 modelName 和 modelObject 是一个 pair；viewName 可以写一个长路径，如 “WEB-INF/jsp/hello.jsp”，更常见的方法是返回一个短字符串，比如 &quot;hello&quot;，交给 ViewResolver 去解析。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;4. DispatchServlet 通过 ViewResolver 来解析 ViewName&lt;/h2&gt;

&lt;p&gt;　　DispatchServlet 默认使用的 ViewResolver 是 InternalResourceViewResolver (更多关于 DispatchServlet 的默认配置请参见 spring-framework-2.5.6.SEC01\src\org\springframework\web\servlet\DispatcherServlet.properties)，但与 BeanNameUrlHandlerMapping 不同的是，虽然 InternalResourceViewResolver 是默认的，但需要进一步对 InternalResourceViewResolver 进行配置。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;!-- spingapp/war/WEB-INF/springapp-servlet.xml --&amp;gt;  
  
&amp;lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;  
    &amp;lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;&amp;gt;&amp;lt;/property&amp;gt;  
    &amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&amp;gt;&amp;lt;/property&amp;gt;  
    &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&amp;gt;&amp;lt;/property&amp;gt;  
&amp;lt;/bean&amp;gt;  
&lt;/pre&gt;


&lt;p&gt;prefix + “hello” + suffix == &quot;/WEB-INF/jsp/hello.jsp&quot;&lt;/p&gt;

&lt;p&gt;　　注意这里的 bean id，虽然在 spring-framework-2.5.6.SEC01\src\org\springframework\web\servlet\DispatcherServlet.java 里有：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public static final String VIEW_RESOLVER_BEAN_NAME = &quot;viewResolver&quot;;  
&lt;/pre&gt;


&lt;p&gt;但这里的bean id可以随便写。&lt;/p&gt;

&lt;p&gt;　　However, MessageSource 类的 bean id 必须是 &quot;messageSource&quot;，不能随便写。我们在 spring-framework-2.5.6.SEC01\src\org\springframework\context\support\AbstractApplicationContext.java 里面可以看到有：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public static final String MESSAGE_SOURCE_BEAN_NAME = &quot;messageSource&quot;;  
&lt;/pre&gt;


&lt;p&gt;　　另外，bean name和bean id 的区别：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Either one would work. It depends on your needs:
If your bean identifier contains special character(s) for example (/viewSummary.html), it (the slash) won&#39;t be allowed as the bean id, because it&#39;s not a valid XML ID. In such cases you could skip defining the bean id and supply the bean name instead.
The name attribute also helps in defining aliases for your bean, since it allows specifying multiple identifiers for a given bean.&lt;/p&gt;&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2&gt;5. JSP dispatched to browser by DispatchServlet&lt;/h2&gt;

&lt;p&gt;　　hello.jsp 被 dispatch 给浏览器显示，注意是 dispatch，所以浏览器的地址栏仍然是 hello.htm。&lt;/p&gt;

&lt;p&gt;　　JSP 可以使用 ModelAndView 中的 Model，形式如 &quot;${ModelName.ModelObject}&quot;，类似于 getAttribute。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;%-- springapp/war/WEB-INF/jsp/hello.jsp --%&amp;gt;  
  
&amp;lt;body&amp;gt;  
    &amp;lt;h1&amp;gt;&amp;lt;fmt:message key=&quot;heading&quot;/&amp;gt;&amp;lt;/h1&amp;gt;  
    &amp;lt;p&amp;gt;&amp;lt;fmt:message key=&quot;greeting&quot;/&amp;gt; &amp;lt;c:out value=&quot;${model.now}&quot;&amp;gt;&amp;lt;/c:out&amp;gt;&amp;lt;/p&amp;gt;  
    &amp;lt;h3&amp;gt;Product&amp;lt;/h3&amp;gt;  
    &amp;lt;c:forEach items=&quot;${model.products}&quot; var=&quot;prod&quot;&amp;gt;  
        &amp;lt;c:out value=&quot;${prod.description}&quot;/&amp;gt;   
        &amp;lt;i&amp;gt;&amp;lt;c:out value=&quot;${prod.price}&quot;/&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  
    &amp;lt;/c:forEach&amp;gt;  
    &amp;lt;br&amp;gt;  
    &amp;lt;a href=&quot;&amp;lt;c:url value=&quot;priceincrease.htm&quot;/&amp;gt;&quot;&amp;gt;Increase Price&amp;lt;/a&amp;gt;  
    &amp;lt;br&amp;gt;  
&amp;lt;/body&amp;gt;  
&lt;/pre&gt;

</description>
                <link>http://erikyao.github.io/springmvc/2009/11/29/spring-mvc-example-anatomy</link>
                <guid>http://erikyao.github.io/springmvc/2009/11/29/spring-mvc-example-anatomy</guid>
                <pubDate>2009-11-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>依赖、依赖注入（DI）以及控制反转（IoC）</title>
                <description>&lt;h2&gt;1. 何为依赖&lt;/h2&gt;

&lt;p&gt;　　不管是面向对象，还是面向过程，一个应用总会分成许多的模块，然后由这些模块协同工作完成任务。要协同工作就会产生依赖，如一个方法调用另一个方法、一个对象包含另一个对象，这些都是依赖关系。&lt;/p&gt;

&lt;p&gt;　　比如：类 A 要包含对象 b 的话，就需要在 A 里 B b =  new B()，这里明显是类 A 依赖对象b&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;2. 何为依赖注入&lt;/h2&gt;

&lt;p&gt;　　Dependency Injection，我讨厌翻译，后续就用 DI 表示好了。&lt;/p&gt;

&lt;p&gt;　　所谓DI，就是由容器动态的生成依赖关系，应用可以方便的获取依赖 (通俗地说就是类 A 不用再亲自 B b = new B() 来获取 b 对象)。从外表上看，就好像是容器将生成的依赖关系注入到应用之中。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;3. DI 的3种实现方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Interface Injection: 类 A 里不是用对象b，而是接口 IB 的实现 ib，ib 由外部创建并传入类 A，类 A 不负责创建工作，如：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class A {  
    private InterfaceB ib;  
      
    public Object doSomething(InterfaceB impB) {  
        ib = impB;  
        return ib.doIt();  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;最典型的例子的是 doGet()、doPost() 方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class HelloServlet extends HttpServlet {  
    public void doGet(HttpServletRequest req, HttpServletResponse resp)   
        throws IOException {
        ...
    }  
}  
&lt;/pre&gt;


&lt;p&gt;这里要注意的是，HttpServletRequest、HttpServletResponse 都是接口，不要再当成是对象了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Setter Injection: 容器来构造 B b = new B()，再使用类 A 的 setter 将 b 注入类 A。不需要类 A 自己动手，只需要类 A 留一个 setter 即可。如 Spring 中 bean.xml 的段&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;bean id=&quot;TheAction&quot; class=&quot;org.xxx.spring.UpperAction&quot;&amp;gt;  
    &amp;lt;property name=&quot;message&quot;&amp;gt;  
        &amp;lt;value&amp;gt;HeLLo&amp;lt;/value&amp;gt;  
    &amp;lt;/property&amp;gt;  
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就指定了调用 UpperAction 的 setMessage(&quot;HeLLo&quot;)。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Constructor Injection: 与 Setter Injection 相对，Construction Injection 就是不使用 setter，而是把对象 b 直接作为参数传给类 A 的构造器。但是容易造成构造器参数列表过长。&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;h2&gt;4. 控制反转&lt;/h2&gt;

&lt;p&gt;　　实际是 Inversion of Control，“控制的反转”，还是用 IoC 表示好了。&lt;/p&gt;

&lt;p&gt;　　IoC，用白话来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓 “控制反转” 的概念所在：控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/spring/2009/11/17/dependency-di-and-ioc</link>
                <guid>http://erikyao.github.io/spring/2009/11/17/dependency-di-and-ioc</guid>
                <pubDate>2009-11-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>jbpm 4.3 variable 的 name 和 mapped-name</title>
                <description>&lt;p&gt;　　看似是一个 variable 有 name 和 mapped-name 两个名称，其实情况很复杂。看例子。&lt;/p&gt;

&lt;p&gt;　　假定我们有一个极其简单的流程 vartest。在 start-state 的 controller 里添加一个 variable，name 为 &quot;var&quot;，mapped-name 为 &quot;variable&quot;，如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;  
  
&amp;lt;process-definition  xmlns=&quot;&quot;  name=&quot;vartest&quot;&amp;gt;  
  
    &amp;lt;start-state name=&quot;start-state1&quot;&amp;gt;  
        &amp;lt;task&amp;gt;  
            &amp;lt;controller&amp;gt;  
                &amp;lt;variable access=&quot;read,write&quot; name=&quot;var&quot; mapped-name=&quot;variable&quot;&amp;gt;&amp;lt;/variable&amp;gt;  
            &amp;lt;/controller&amp;gt;  
        &amp;lt;/task&amp;gt;  
        &amp;lt;transition to=&quot;task-node1&quot;&amp;gt;&amp;lt;/transition&amp;gt;  
    &amp;lt;/start-state&amp;gt;  
  
    &amp;lt;task-node name=&quot;task-node1&quot;&amp;gt;   
        &amp;lt;transition to=&quot;end-state1&quot;&amp;gt;&amp;lt;/transition&amp;gt;  
    &amp;lt;/task-node&amp;gt;  
  
    &amp;lt;end-state name=&quot;end-state1&quot;&amp;gt;&amp;lt;/end-state&amp;gt;  
  
&amp;lt;/process-definition&amp;gt;
&lt;/pre&gt;


&lt;p&gt;　　然后我们来写一个 Test Case：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class AccessVariable extends TestCase {
    public void testPayProcess() throws Exception {  
        JbpmContext jc = JbpmConfiguration.getInstance().  
                createJbpmContext();  
          
        ProcessDefinition pd = jc.getGraphSession().  
                findLatestProcessDefinition(&quot;vartest&quot;);  
        ProcessInstance pi = pd.createProcessInstance();  
        ContextInstance ci = pi.getContextInstance();  
        TaskInstance ti = pi.getTaskMgmtInstance().createStartTaskInstance()  
          
        // hint 1:  
        // ci can create new variable (not declared in &amp;lt;controller&amp;gt;)  
        // and ti can access the variable ci created  
        ci.setVariable(&quot;abc&quot;, &quot;ABC&quot;);  
        System.out.println(ti.getVariable(&quot;abc&quot;)); // ABC  
        ti.setVariable(&quot;abc&quot;, &quot;CBA&quot;);  
        System.out.println(ci.getVariable(&quot;abc&quot;)); // CBA  
      
        // hint 1:     
        // also, ti can create this kind of variables  
        // and ci can access the variable ti created  
        ti.setVariable(&quot;def&quot;, &quot;DEF&quot;);  
        System.out.println(ci.getVariable(&quot;def&quot;)); // DEF      
        ci.setVariable(&quot;def&quot;, &quot;FED&quot;);  
        System.out.println(ti.getVariable(&quot;def&quot;)); // FED  
          
        // hint 2:         
        // for the variables declared in &amp;lt;controller&amp;gt;, it&#39;s the same situation  
        // both ci and ti can create and access this kind of variable  
        ci.setVariable(&quot;var&quot;, &quot;VAR&quot;);  
        System.out.println(ti.getVariable(&quot;var&quot;)); // VAR  
        ti.setVariable(&quot;var&quot;, &quot;RAV&quot;);  
        System.out.println(ci.getVariable(&quot;var&quot;)); // RAV  
  
        // hint 3:     
        // &quot;var&quot; doesn&#39;t affect &quot;variable&quot;  
        System.out.println(ti.getVariable(&quot;variable&quot;)); // null  
        System.out.println(ci.getVariable(&quot;variable&quot;)); // null  
  
        // hint 4:     
        // things becaome a little different when using mapped-name  
        ti.setVariable(&quot;variable&quot;, &quot;VARIABLE&quot;);  
        System.out.println(ti.getVariable(&quot;variable&quot;)); // VARIABLE  
        System.out.println(ci.getVariable(&quot;variable&quot;)); // null  
      
        // hint 4:     
        // it&#39;s clear that ti and ci both holds an &quot;variable&quot;, respectively  
        ci.setVariable(&quot;variable&quot;, &quot;ELBAIRAV&quot;);  
        System.out.println(ti.getVariable(&quot;variable&quot;)); // VARIABLE  
        System.out.println(ci.getVariable(&quot;variable&quot;)); // ELBAIRAV  
  
        // hint 3:     
        // and &quot;variable&quot; doesn&#39;t affect &quot;var&quot;  
        System.out.println(ti.getVariable(&quot;var&quot;)); // RAV  
        System.out.println(ci.getVariable(&quot;var&quot;)); // RAV  
              
        ti.end();  
        pi.end();  
        jc.close();  
    }
}
&lt;/pre&gt;


&lt;p&gt;　　可以看出，除了 mapped-name 之外，ti 和 ci 可以随意 setVariable(key, value)，setVariable 的过程包含了 create 的过程，key 可以是 name，也可以是其他字符串，且这种类型的变量 (名称为 name 或是任意字符串，只要不是 mapped-name) ti 和 ci 可以随意访问，这类变量对 ti 和 ci 的作用域是一样的 (类似于全局变量)。&lt;/p&gt;

&lt;p&gt;　　但 name 和 mapped-name 变量没有任何关系，如 hint 3 所示，&quot;var&quot; 的值不会影响 &quot;variable&quot;，反过来 &quot;variable&quot; 的值也不会影响 &quot;var&quot;。&lt;/p&gt;

&lt;p&gt;　　且 mapped-name 变量对 ti 和 ci 来说更像是2个变量，其作用域严格区分，没有任何交集，如 hint 4 所示。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/jbpm-4.3/2009/11/14/jbpm4-variables-name-and-mapped-name</link>
                <guid>http://erikyao.github.io/jbpm-4.3/2009/11/14/jbpm4-variables-name-and-mapped-name</guid>
                <pubDate>2009-11-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>IR 经典模型之向量模型</title>
                <description>&lt;h2&gt;1. 向量模型同样将 dj 和 qcc 同级计算，采用的同级方式是扩展 qcc 到 t 维&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2&gt;2. 相似度计算&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;依旧有 dj = {w1j, w2j, …, wtj}，但这里的 wij 不再是二元值，而是一个加权值；同样定义qcc = {w1, w2, ..., wt}，这里的 wi 也是一个加权值&lt;/li&gt;
&lt;li&gt;sim(dj, qcc) = dj • qcc / (|dj| * |qcc|)， dj • qcc为向量点乘运算&lt;/li&gt;
&lt;li&gt;一次检索的过程是根据 qcc 来和所有 dj ∈ D (文档集合)，计算出一组 sim 值，然后依据 sim 值来排序 D，返回前排部分文档 (可自定义阈值，比如返回 sim 值大于 0.5 的或是 D 排序后的前 30% 文档)&lt;/li&gt;
&lt;li&gt;|dj|² = ∑i (wij²)；|qcc|² = ∑i (wi²)，对于一次检索而言，|qcc| 值对排序不会产生任何影响；dj • qcc =  ∑i (wij * wi)&lt;/li&gt;
&lt;li&gt;term freqency (词频)：表示词 ki 在文档 dj 中出现的频率，TFij = Nij / ∑t Ntj，Nij 为词 ki 在文档 dj 中出现的次数，∑t Ntj 为所有词在文档 dj 中出现的次数和，即 dj 包含的总词数。若词 ki 的 TF 值越高，则说明 ki 越能代表文档 dj&lt;/li&gt;
&lt;li&gt;inverse doucument frequency (逆向文档频率)：设 |Di| = {d|d∈D 且 ki∈d}，|Di| 值即表示文档集 D 中有这么多篇文档包含了词 ki；IDFi = log(|D| / |Di|)，|D| 为文档集中的文档个数。若 IDFi 值越大，说明 D 中包含 ki 的文档越少，从而 ki 用来区分 D 中不同文档的能力也就越大。&lt;/li&gt;
&lt;li&gt;wij = TFij * IDFi&lt;/li&gt;
&lt;li&gt;wi = (½ + ½ * TFij) * IDFi&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://erikyao.github.io/information-retrieval/2009/11/01/vector-space-model</link>
                <guid>http://erikyao.github.io/information-retrieval/2009/11/01/vector-space-model</guid>
                <pubDate>2009-11-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>IR 经典模型之布尔模型</title>
                <description>&lt;h2&gt;1. 经典模型的前提概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;以 ki 表示 indexing item，K = {k1, k2, …, kt} 为整个系统的 indexing item 集，即整个系统只有 t 个 indexing item&lt;/li&gt;
&lt;li&gt;针对文档 dj，wij 为 ki 在 dj 中的权值，若 ki 没有在 dj 中出现，则 wij = 0&lt;/li&gt;
&lt;li&gt;dj 可以表示为 dj = {w1j, w2j, …, wtj}&lt;/li&gt;
&lt;li&gt;gi(dj) = wij&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. 布尔模型中的查询 q&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;q 由若干 ki、连接词 AND、OR、NOT 构成，比如 q = ka AND (kb OR (NOT kc))&lt;/li&gt;
&lt;li&gt;q 可以写成一个析取范式 qdnf = (1, 1, 1)∨(1, 1, 0)∨(1, 0, 0)，三元组 (1, 1, 1) 称为 qdnf 的一个合取分量 qcc&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3. 布尔模型中的相似度&lt;/h2&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
if 存在 qcc ∈ qdnf 满足对任意 ki，gi(dj) = wij = gi(qcc) 
    则 sim(dj, q) = 1，即文档 dj 与查询 q 相关  
else 
    sim(dj, q) = 0，即文档 dj 与查询 q 无关 
&lt;/pre&gt;


&lt;h2&gt;4. 对 gi(qcc) 的理解&lt;/h2&gt;

&lt;p&gt;　　考虑到 dj 是个 t 元组，形如 dj = {1, 0, 1, 1, ..., 0, 0}，“对任意ki，gi(dj) = wij = gi(qcc)” 从实质上就是 dj = qcc。但是，qcc 中并不会包含所有 t 个 indexing item，设 |qcc| = n，一般情况下 t != n，所以可以从以下两个方面理解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;扩展qcc到t元&lt;/li&gt;
&lt;li&gt;截取(或者叫投影)dj到n元&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;举例：dj = (w1j = 0, w2j = 1, w3j = 1)，qcc = (w2 = 1, w3 = 1)。扩展dj (投影 dj 到 (w2, w3))，dj&#39; = (w2j = 1, w3j = 1) = qcc；扩展 qcc，qcc&#39; = (w1 = 0, w2 = 1, w3 = 1) = dj&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/information-retrieval/2009/11/01/boolean-information-retrieval</link>
                <guid>http://erikyao.github.io/information-retrieval/2009/11/01/boolean-information-retrieval</guid>
                <pubDate>2009-11-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>当接口方法有声明 throws Exception 时，实现方法可以选择不 throws</title>
                <description>&lt;p&gt;　　RT。自己试试就好了，废话不多说了。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/10/31/implemention-method-can-choose-not-to-throw</link>
                <guid>http://erikyao.github.io/java/2009/10/31/implemention-method-can-choose-not-to-throw</guid>
                <pubDate>2009-10-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>a simple delegation example</title>
                <description>

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {  
    doGet(req, resp);  
}  
&lt;/pre&gt;


&lt;p&gt;　　简直是最简单也最直白的例子了。我们称 doPost() delegates its function to doGet() 或者说 doPost() delegates doGet() to function。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/10/31/a-simple-delegation-example</link>
                <guid>http://erikyao.github.io/java/2009/10/31/a-simple-delegation-example</guid>
                <pubDate>2009-10-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>windows 下查看端口是否被占用的方法</title>
                <description>&lt;p&gt;　　假如我们需要确定谁占用了我们的80端口。&lt;/p&gt;

&lt;p&gt;　　在windows命令行窗口下执行：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
C:\&gt;netstat -aon|findstr &quot;80&quot;
TCP     127.0.0.1:80         0.0.0.0:0               LISTENING       2448
&lt;/pre&gt;


&lt;p&gt;　　看到了吗，端口被进程号为2448的进程占用，继续执行下面命令：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
C:\&gt;tasklist|findstr &quot;2448&quot;
thread.exe                     2016 Console                 0     16,064 K
&lt;/pre&gt;


&lt;p&gt;很清楚吧，thread占用了你的端口，Kill it&lt;/p&gt;

&lt;p&gt;　　如果第二步查不到，那就开任务管理器，看哪个进程是2448，然后杀之即可。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/windows/2009/10/25/who-is-using-my-window-ports</link>
                <guid>http://erikyao.github.io/windows/2009/10/25/who-is-using-my-window-ports</guid>
                <pubDate>2009-10-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Ant 中 javac 假死的解决办法</title>
                <description>&lt;p&gt;　　当前项目用的是 eclipse 3.5，然后文件编码都是 utf-8。在执行 Ant 脚本时，javac 死活不动，解决方案是：右键 build.xml --&gt; run as --&gt; External Tools Configurations --&gt; Common 选项卡 --&gt; Console Encoding 选择 utf-8。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/ant/2009/10/25/javac-inactive-in-ant</link>
                <guid>http://erikyao.github.io/ant/2009/10/25/javac-inactive-in-ant</guid>
                <pubDate>2009-10-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>jBPM 4.3 自动保存 TaskInstance 至数据库的机制</title>
                <description>&lt;ol&gt;
&lt;li&gt;org.jbpm 包下的 JbpmContext 类:&lt;/li&gt;
&lt;/ol&gt;


&lt;pre class=&quot;prettyprint linenums&quot;&gt;
close()  
    --&gt; autoSave()  
        --&gt; save(ProcessInstance)  
            --&gt; services.save(ProcessInstance, JbpmContext)
&lt;/pre&gt;


&lt;p&gt;　　services 是 JbpmContext 类的 Services 类变量&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;org.jbpm.svc 包下的 Services 类:&lt;/li&gt;
&lt;/ol&gt;


&lt;pre class=&quot;prettyprint linenums&quot;&gt;
save(ProcessInstance, JbpmContext)  
    --&gt; for (saveOperation: SaveOperations)   
        saveOperation.save(ProcessInstance, JbpmContext)  
&lt;/pre&gt;


&lt;p&gt;&lt;/p&gt;

&lt;p&gt;　　saveOperation 是 SaveOpration 类型，且如果不带参构造的话，SaveOperations 列表会等于 defaultSaveOperations 列表，而 defaultSaveOperations 列表中有一项是 HibernateSaveOperation&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;org.jbpm.svc.save 包下的 HibernateSaveOperation 类&lt;/li&gt;
&lt;/ol&gt;


&lt;pre class=&quot;prettyprint linenums&quot;&gt;
save(ProcessInstance, JbpmContext)  
    --&gt;session.save(ProcessInstance)
&lt;/pre&gt;


&lt;p&gt;　　已经能够说明问题了吧……&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/jbpm-4.3/2009/10/25/how-does-jbpm4-autosave-taskinstance</link>
                <guid>http://erikyao.github.io/jbpm-4.3/2009/10/25/how-does-jbpm4-autosave-taskinstance</guid>
                <pubDate>2009-10-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Tomcat 6.0 环境变量和 Tomcat Manager Account</title>
                <description>&lt;p&gt;　　有的文章上说只用 CATALINA_HOME 这么一个，也有的说是 CATALINA_HOME、CATALINA_BASE、TOMCAT_HOME 这3个。我看 Tomcat Document ，CATALINA_HOME 好像是必须的，还有地方提到了 CATALINA_BASE，既然这样的话，那就三个都设置好了。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
CATALINA_HOME = x:\apache-tomcat-yyy  
CATALINA_BASE = x:\apache-tomcat-yyy  
TOMCAT_HOME   = x:\apache-tomcat-yyy 
&lt;/pre&gt;


&lt;p&gt;　　&lt;em&gt;注意&lt;/em&gt;：如果环境变量的内容只有一项的话，就不要加分号了 (如设置 CATALINA_HOME 为“x:\apache-tomcat-yyy;&quot;)，否则的话 startup 和 shutdown 会有问题，双击不显示信息，窗口一闪而过。&lt;/p&gt;

&lt;p&gt;　　然后更新 classpath 和 Path。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
classpath = %CATALINA_HOME%\lib\servlet-api.jar;  
Path      = %CATALINA_HOME%\bin;
&lt;/pre&gt;


&lt;p&gt;　　环境变量就OK了。&lt;/p&gt;

&lt;p&gt;　　设置一个 Tomcat Manager Account 只用修改 CATALINA_HOME\conf\tomcat-user.xml，更新 &lt;tomcat-users&gt;&lt;/tomcat-users&gt; 块，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;tomcat-users&amp;gt;  
    &amp;lt;role rolename=&quot;manager&quot;/&amp;gt;   
    &amp;lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;manager&quot;/&amp;gt;  
&amp;lt;/tomcat-users&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就能登录在 http://localhost:zzzz/ 页面左侧的 Tomcat Manager 了。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/tomcat/2009/10/03/minimal-tomcat-6-config</link>
                <guid>http://erikyao.github.io/tomcat/2009/10/03/minimal-tomcat-6-config</guid>
                <pubDate>2009-10-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>class loading: further discussion involving steps of instance creation</title>
                <description>&lt;p&gt;　　本文对 &lt;a href=&quot;/java/2009/03/19/initializer/&quot;&gt;initializer&lt;/a&gt;、&lt;a href=&quot;/java/2009/03/25/class-loading-an-example/&quot;&gt;class loading: an example&lt;/a&gt;、&lt;a href=&quot;/java/2009/03/27/using-overridden-method-in-constructor-is-dangerous/&quot;&gt;warning: 在构造器中请谨慎使用被覆写方法&lt;/a&gt; 做统一归纳。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　一个类在能够被程序使用之前，必须经历三个准备工作 (以下统称为类的执行)：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;loading&lt;/li&gt;
&lt;li&gt;linking

&lt;ol&gt;
&lt;li&gt;verification&lt;/li&gt;
&lt;li&gt;preparation&lt;/li&gt;
&lt;li&gt;resolution (optional)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;inintialization&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　在 &lt;a href=&quot;/java/2009/03/25/class-loading-an-example/&quot;&gt;class loading: an example&lt;/a&gt;、&lt;a href=&quot;/java/2009/03/27/using-overridden-method-in-constructor-is-dangerous/&quot;&gt;warning: 在构造器中请谨慎使用被覆写方法&lt;/a&gt; 中，我们使用的loading (加载)，其实是统指了以上三个步骤。&lt;/p&gt;

&lt;p&gt;　　loading 指从 .class 文件中读取类的 binary representation (即类的 Class 对象) 的过程。&lt;/p&gt;

&lt;p&gt;　　verfication 过程验证 binary representation 的结构是否正确。&lt;/p&gt;

&lt;p&gt;　　preparation 过程为类的 static field 申请空间并赋默认值，同时为类的一些内部数据结构 (如方法列表) 申请空间。&lt;/p&gt;

&lt;p&gt;　　resolution 过程分析类中的引用。resolution 过程是一个 optional 的过程，在 resolution 过程中可以有不同的 loading 策略，比如说，在 resolve class A 的时候，发现 class A 中有一个 class B 的引用，此时可以立即加载 class B，也可以 do nothing。&lt;/p&gt;

&lt;p&gt;　　initialization 过程执行 static initializer 和 initializer for static field (i.e. static variable initializer)。如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
private static int i = 5; // static variable initializer  
  
// static initializer  
static {  
    ......  
}
&lt;/pre&gt;


&lt;p&gt;　　以下 &lt;em&gt;&lt;strong&gt;不&lt;/strong&gt;&lt;/em&gt; 属于 initialization 阶段执行的代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
private int i = StaticFunction(); // 虽然涉及到了 static 方法，不过 field 不是 static，不能算是 static variable initialzer  
  
//虽然是对 static field 初始化，但这个 initializer 本身不是 static，依旧不能算是 static initializer  
{  
    StaticField = xxx;  
    ......  
}
&lt;/pre&gt;


&lt;p&gt;　　由于 loading 和 linking 过程是 implementation-dependent，且不方便追踪和查看，所以暂不讨论 loading 和 linking 的触发条件。以下着重讨论 initialization。&lt;/p&gt;

&lt;p&gt;　　initialization 三原则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;触发原则：以下三种场景 &lt;em&gt;&lt;strong&gt;执行之前&lt;/strong&gt;&lt;/em&gt; 会触发 initialization

&lt;ul&gt;
&lt;li&gt;创建类的实例 (constrcutor or Class.newInstance())&lt;/li&gt;
&lt;li&gt;调用类的 static 方法 (包括 constructor)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;非&lt;/strong&gt;&lt;/em&gt; final 的 static field is used or assigned&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;父类原则：子类 initialization 之前，其 direct 父类必须 initialization，and so recursively. (p.s. 类实现的接口无需 initialization，类实现的接口的父接口亦无需如此)&lt;/li&gt;
&lt;li&gt;引发原则：如果子类 initialization 引发了父类的 initialization，而此时父类还没有 loading 和 linking，则父类的 loading 和 linking 也会被引发 (&lt;em&gt;p.s.&lt;/em&gt; 我觉得子类的 initialization 同样可以引发子类的 loading 和 linking，如果 loading 和 linking 还没有执行的话)。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　这里需要着重强调的是：loading、linking 和 initialization 都是类的行为 (class behavior) (所以 initialization 执行的都是 static)，而实例的创建 (constructor or Class.newInstance()) 则是对象行为 (object behavior)。&lt;/p&gt;

&lt;p&gt;　　constructor 执行的过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行 this() or super()&lt;/li&gt;
&lt;li&gt;执行 initializer 和 non-static variable initializer&lt;/li&gt;
&lt;li&gt;执行 constructor 的余下部分&lt;/li&gt;
&lt;/ol&gt;


&lt;hr /&gt;

&lt;p&gt;回头看 &lt;a href=&quot;/java/2009/03/25/class-loading-an-example/&quot;&gt;class loading: an example&lt;/a&gt; 的例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
import static java.lang.System.out;  
  
class Insect {  
    private int i = 1;  
    protected int j;  
    private static int x1 = printInit(&quot;static Insect.x1 initialized&quot;);  
      
    Insect() {  
        out.println(&quot;Insect constructor&quot;);  
        out.println(&quot;i = &quot; + i + &quot;, j = &quot; + j + &quot;, x1 = &quot; + x1);  
        this.j = 2;  
    }  
      
    static int printInit(String s) {  
        out.println(s);  
  
        return 3;  
    }  
}  
  
public class Beetle extends Insect {  
    private int k = printInit(&quot;Beetle.k initialized&quot;);  
    private static int x2 = printInit(&quot;static Beetle.x2 initialized&quot;);  
      
    public Beetle() {  
        out.println(&quot;Beetle constructor&quot;);  
        out.println(&quot;j = &quot; + j + &quot;, k = &quot; + k + &quot;, x2 = &quot; + x2);  
    }  
   
    public static void main(String[] args) {  
        Beetle b = new Beetle();  
    }  
}  
//output:  
/* 
    static Insect.x1 initialized 
    static Beetle.x2 initialized 
    Insect constructor 
    i = 1, j = 0, x1 = 3 
    Beetle.k initialized 
    Beetle constructor 
    j = 2, k = 3, x2 = 3 
*/ 
&lt;/pre&gt;


&lt;ol&gt;
&lt;li&gt;访问 Insect 的 main 方法，是个 static，引发 Beetle 的 loading、linking 和 initialization，initialization 又引发 Insect 的 loading、linking和 initialization

&lt;ul&gt;
&lt;li&gt;执行 Insect 的 initialization，private static int x1( = 3)，打印 &quot;static Insect.x1 initialized&quot;&lt;/li&gt;
&lt;li&gt;执行 Beetle 的 initialization，private static int x2( = 3)，打印 &quot;static Beetle.x2 initialized&quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进入 main()，发现 constructor&lt;/li&gt;
&lt;li&gt;隐式调用 super()，转到 Insect 的 constructor

&lt;ul&gt;
&lt;li&gt;Insect 已经 loading、linking 和 initialization了，直接执行 non-static variable initializer，初始化 private int i( = 1) 和 protected int j( = 0 by default)&lt;/li&gt;
&lt;li&gt;执行 Insect constructor 的余下部分，打印 &quot;Insect constructor&quot; 和 &quot;i = 1, j = 0, x1 = 3&quot;，然后j = 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;执行 Beetle 的 non-static variable initializer，初始化 private int k( = 3)，打印 &quot;Beetle.k initialized&quot;&lt;/li&gt;
&lt;li&gt;执行 Beetle constructor 的余下部分，打印 &quot;Beetle constructor&quot; 和 &quot;j = 2, k = 3, x2 = 3&quot;&lt;/li&gt;
&lt;/ol&gt;


&lt;hr /&gt;

&lt;p&gt;回头看 &lt;a href=&quot;/java/2009/03/27/using-overridden-method-in-constructor-is-dangerous/&quot;&gt;warning: 在构造器中请谨慎使用被覆写方法&lt;/a&gt; 的例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Glyph {  
    void draw() {   
        System.out.println(&quot;Glyph.draw()&quot;);  
    }  
      
    Glyph() {  
        System.out.println(&quot;Glyph constructor&quot;);  
        draw();  
    }  
}     
  
class RoundGlyph extends Glyph {  
    private int radius = 1;  
  
    RoundGlyph(int r) {  
        System.out.println(&quot;before assignment in constructor, radius = &quot; + radius);  
        radius = r;  
        System.out.println(&quot;RoundGlyph constructor, radius = &quot; + radius);  
    }  
      
    void draw() {  
        System.out.println(&quot;RoundGlyph.draw(), radius = &quot; + radius);  
    }  
}     
  
public class PolyConstructors {  
    public static void main(String[] args) {  
        new RoundGlyph(5);  
    }  
}  
//Output:  
/* 
    Glyph constructor 
    RoundGlyph.draw(), radius = 0 
    before assignment in constructor, radius = 1 
    RoundGlyph constructor, radius = 5 
*/ 
&lt;/pre&gt;


&lt;ol&gt;
&lt;li&gt;访问 PolyConstructors 的 main 方法，loading、linking PolyConstructors，进入 main，发现 RoundGlyph 构造器&lt;/li&gt;
&lt;li&gt;隐式调用 super()，打印 &quot;Glyph constructor&quot;，执行 RoundGlyph 的 draw() 方法，打印 &quot;RoundGlyph.draw(), radius = 0&quot; (此时还没有执行到 RoundGlyph 的 non-static variable initializer)&lt;/li&gt;
&lt;li&gt;执行 RoundGlyph 的 non-static variable initializer，radius = 1&lt;/li&gt;
&lt;li&gt;执行 RoundGlyph 构造器的余下部分，打印 &quot;before assignment in constructor, radius = 1&quot;，然后 radius = 5，打印 &quot;RoundGlyph constructor, radius = 5&quot;&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://erikyao.github.io/java/2009/09/04/class-loading-further-discussion-involving-steps-of-instance-creation</link>
                <guid>http://erikyao.github.io/java/2009/09/04/class-loading-further-discussion-involving-steps-of-instance-creation</guid>
                <pubDate>2009-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>the proxy parameter of the invoke() method</title>
                <description>&lt;p&gt;　　关于动态代理，一般的代码结构为：一个业务接口、一个业务接口的实现、一个自定义的 InvocationHandler 实现和 main 类，如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
import java.lang.reflect.*;

interface Inf {
    public void print(String s);
}

class Imp implements Inf {
    public void print(String s) {
        System.out.println(s);
    }
}

class MyProxyHandler implements InvocationHandler {
    private Object target;

    public MyProxyHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        return method.invoke(target, args);
    }
}

public class ProxyTest {
    public static void main(String[] args) {
        Inf infProxy = (Inf) Proxy.newProxyInstance(Inf.class.getClassLoader(),
                new Class[] { Inf.class }, new MyProxyHandler(new Imp()));

        infProxy.print(&quot;Hello World&quot;);
    }
}
&lt;/pre&gt;


&lt;p&gt;　　其中 newProxyInstance 虽然返回的是 Object，但只能转换成 Interface；newProxyInstance 同时也相当于起到一个“注册”的作用，即注册 infProxy 使用参数一来加载 (Inf.class.getClassLoader())、实现了参数二所示的一系列 Interface (这里用 Class 类来表示)、具体使用参数三的实现 (即 infProxy 代理的是 Imp，通过 MyProxyHandler 来中转)。&lt;/p&gt;

&lt;p&gt;　　这里说的“中转”，其实是通过 invoke 方法。针对 infProxy.print(&quot;Hello World&quot;)，我们会发现，invoke 的三个参数中，Method method 是 print，Object[] args 是 &quot;Hello World&quot;，Object Proxy 根本没有使用，而且我们在 MyProxyHandler 中还添加了一个 Object target 来接收 new Imp()。&lt;/p&gt;

&lt;p&gt;　　按照 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/InvocationHandler.html&quot;&gt;JDK文档&lt;/a&gt; 的说法：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;proxy - the proxy instance that the method was invoked on&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　查到的 &lt;a href=&quot;http://tutorials.jenkov.com/java-reflection/dynamic-proxies.html&quot;&gt;一篇博文&lt;/a&gt; 有说：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The proxy parameter passed to the invoke() method is the dynamic proxy object implementing the interface. Most often you don&#39;t need this object.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　曾经我很困惑：“这个 proxy 参数倒是是干嘛用的？” 其实也不是啥大不了的事：你 MyProxyHandler 不是自己加了个 Object target 来接收 new Imp() 么？那我同样也可以加一个 Object proxy 来接收 new ImpProxy() 啊。这里 invoke 让你可以用三个参数来实现，看你个人喜欢。&lt;/p&gt;

&lt;p&gt;　　最后感谢 &lt;a href=&quot;http://chaisencs.iteye.com/&quot;&gt;chaisencs&lt;/a&gt; 网友提到：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;你去看一下这个类 RemoteObjectInvocationHandler 的源代码，就知道参数 proxy 其实是有用的&lt;/p&gt;&lt;/blockquote&gt;
</description>
                <link>http://erikyao.github.io/java/2009/08/13/proxy-parameter-of-the-invoke-method</link>
                <guid>http://erikyao.github.io/java/2009/08/13/proxy-parameter-of-the-invoke-method</guid>
                <pubDate>2009-08-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>throw 的屏蔽作用</title>
                <description>&lt;p&gt;　　在其所在的块内 (如方法 body、if () {...} 等)，throw 语句可以屏蔽其后的语句，即在块内，该 throw 语句后面不能再写其他语句；但在块之外，还是可以写其他的语句的。如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class ExceptionTest {  
    private static void func() throws Exception {  
        throw new Exception();  
        //System.out.println(&quot;Threw Exception&quot;); // error  
    }  
  
    private static void func2() throws Exception {  
        boolean tag = true;  
          
        if (tag) {  
            throw new Exception();  
            //System.out.println(&quot;Threw Exception&quot;); // error  
        }  
        System.out.println(&quot;No Exception&quot;); // pass // Mark No.3  
    }  
  
    public static void main(String[] args) {  
        try {  
            func2(); // Mark No.1  
            throw new Exception(); // Mark No.2: direct throw in try  
        } catch (Exception e) {  
            System.out.println(&quot;Caught Exception&quot;);  
        }  
          
        System.out.println(&quot;Continue&quot;); // Mark No.4  
    }  
}  
  
//output:  
/* 
    Caught Exception 
    Continue 
*/  
&lt;/pre&gt;


&lt;p&gt;　　如果不是直接在 try 中抛出异常 (Mark No.2)，而是调用会抛出异常的方法 (Mark No.1)，一旦 throw 语句执行，则包含该 throw 语句的方法 (如本例的 func2()) 直接退出，后续的语句都不执行 (如 Mark No.3 处就没有运行)。而处理异常的函数 (如本例的 main()) 依旧是顺序运行，不会有什么影响，后续的语句继续运行 (如 Mark No.4 处照常运行)。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011-10-27补充&lt;/em&gt;：多个throw的覆盖作用&lt;/p&gt;

&lt;p&gt;　　如果你 throw 了一个 Exception，紧接着后面的 catch/finally 也 throw 了一个 Exception，那么，只有最后抛出的 Exception 才能被外围捕捉，前面 throw 的 Exception 就被覆盖掉了。&lt;/p&gt;

&lt;p&gt;　　一个典型的可能的例子是：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
try {  
    // 读文件  
} finally {   
    if (io != null) {  
        io.close();  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;如果读文件时出了 FileNotFoundException，而不巧 io.close() 也出了 IOException，那么外围只能捕捉到 IOException，而真实的原因 FileNotFoundException 却捕捉不到。&lt;/p&gt;

&lt;p&gt;　　&lt;em&gt;Practical Java&lt;/em&gt; 上一个略奇葩的思路是用一个 Collection 来保存 Exception，最后 throw 出一个 AllException(Collection&lt;Exception&gt; c) 这样的异常出来。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/08/04/throw-clause-directs-execution</link>
                <guid>http://erikyao.github.io/java/2009/08/04/throw-clause-directs-execution</guid>
                <pubDate>2009-08-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>涉及继承的异常声明及捕捉</title>
                <description>&lt;p&gt;　　当有继承发生时，会伴随着重载、覆写 (包括接口方法的实现)、构造器的重写等行为。此时，如果基类或是接口的方法存在异常声明，那么导出类或是接口的实现类的对应方法该如何声明异常？同时对这些方法的调用该如何捕捉异常？下面就这2个问题进行探讨，你会看到，针对覆写和构造器的重写是2种完全不同的处理方式 (针对重载则没有任何限制)。代码如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class ExtException extends Exception {}  
class AnotherException extends Exception {}  
  
class Base {  
    public void func() {}  
      
    public void func2() throws Exception {}  
    public void func3() throws ExtException {}  
      
    public Base() throws Exception {}  
    public Base(int i) throws Exception {}  
    //public Base(float f) throws ExtException{} // Error No.5: every other constructor will call the default constructor; same as Error No.4  
}  
  
interface Inf {  
    public void func2() throws ExtException;  
    // public void func3() throws AnotherException; // Error No.3: base and interface conflict
      
    public void func4() throws Exception;  
    public void func5() throws Exception;  
}  
  
class ExtImp extends Base implements Inf {  
    // public void func()  throws ExtException{} // Error No.1: if base method has no exception declaration, overriding CANNOT add one  
      
    // public void func2() throws Exception {} // Error No.2: cannot implement interface; base and interface conflict 
    public void func2() throws ExtException {} // implement interface with Hint No.2  
      
    // public void func3() throws ExtException {} // Error No.3  
    // public void func3() throws AnotherException {} // Error No.3  
      
    public void func4() {} // Hint No.1: if base method has exception declaration, overriding CAN ommit  
    public void func5() throws ExtException {} // Hint No.2: if base method has exception declaration, overriding CAN declare ext exception  
      
    // public ExtImp() {} // Error No.4: ext&#39;s construcor must declare the exact exception the base constructor declares  
    public ExtImp() throws Exception {}   
    // public ExtImp() throws ExtException {} // Error No.4  
      
    public ExtImp(int i) throws Exception, ExtException {} // Hint No.3: once ext decalres throwing the base&#39;s exception, it CAN declare other exception (不一定非要是父类声明异常的子类)
      
    // public ExtImp(float f) throws ExtException{} // Error No.5  
}  
&lt;/pre&gt;




&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class ExtException extends Exception {}  
class AnotherException extends Exception {}  
class ThirdException extends Exception {}  
class FourthException extends ThirdException {}  
  
class Base {  
    public Base() {}  
    public Base(int i) throws ExtException {}  
    public Base(float f) throws ExtException {}  
      
    public void func() throws ThirdException { System.out.println(&quot;Base.func()&quot;); }  
}  
  
class Ext extends Base {  
    public Ext() throws Exception {}  // Hint No.4: ext&#39;s constructor CAN add exception declaration  
    public Ext(int i) throws ExtException, AnotherException {} // Hint No.4  
    public Ext(float f) throws Exception {} // Hint No.5: ext&#39;s constructor can declare base exception  
      
    public void func() throws FourthException { System.out.println(&quot;Ext.func()&quot;); }  
}  
  
public class Example2 {  
    public static void main(String[] args) {  
        try {  
            Ext e = new Ext(5);  
            e.func();  
        } catch (ExtException ee) {}  
        catch (AnotherException ae) {}  
        catch (FourthException fe) {} // ***DIFFERENCE***  
      
        try {  
            Base b = new Ext(5);  
            b.func();  
        } catch (ExtException ee) {}  
        catch (AnotherException ae) {}  
        catch (ThirdException te) {} // ***DIFFERENCE***  
    }  
}  
  
//output:  
/* 
    Ext.func() 
    Ext.func() 
*/  
&lt;/pre&gt;


&lt;p&gt;　　针对覆写方法，有以下几点原则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果基类方法没有声明异常，那么导出类的覆写方法也不能声明异常 (Error No.1)。&lt;/li&gt;
&lt;li&gt;如果基类方法有声明异常，那么导出类的覆写方法可以：(1)不声明异常；(2)声明抛出基类方法的异常；(3)声明抛出基类方法异常的导出类。(Hint No.1 &amp;amp; Hint No.2)&lt;/li&gt;
&lt;li&gt;如果基类和接口有同签名方法，且导出类实现了接口，如果基类方法和接口方法声明的异常不同，则称基类与接口冲突。如果基类方法抛出的异常和接口方法声明的异常存在继承关系，则实现接口的导出类必须声明抛出导出异常 (子异常) (Error No.2)；如果如果基类方法声明的异常和接口方法声明的异常不存在继承关系，则冲突不可调和，需要修改基类或是接口 (Error No.3)。&lt;/li&gt;
&lt;li&gt;由 Example2 可见，对于向上转型 Base b = new Ext(5)，调用 b.func() 虽然会动态绑定调用 Ext 的 func() 方法，可是 &lt;em&gt;&lt;strong&gt;异常捕捉必须按照 Base 的 func() 方法的异常声明来捕捉&lt;/strong&gt;&lt;/em&gt; (见 DIFFERENCE 处)。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　针对构造器的重写，有以下几点原则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;这里应该持这么一种观点，基类的带参构造器和导出类的所有构造器都默认调用了基类的默认构造器，Base(int i) 调用了 Base()，Ext() 调用了 super()，Ext(int i) 调用了 super(i)，依次类推。所以一旦基类的默认构造器声明了异常，那么基类的带参构造器和导出类的所有构造器都必须声明异常，异常类型可以是基类默认构造器的异常或是其基类，而决不能是其导出类 (Error No.4, Error No.5 &amp;amp; Hint No.5) (与覆写方法抛异常的情况刚好相反)。&lt;/p&gt;

&lt;p&gt; &lt;em&gt;p.s.&lt;/em&gt; 导出类构造器虽然不能声明导出异常，不过可以抛出导出异常，如：&lt;/p&gt;

&lt;p&gt; &lt;pre class=&quot;prettyprint linenums&quot;&gt;
 class Base {&lt;br/&gt;
     public Base() throws NullPointerException {}
 }&lt;/p&gt;

&lt;p&gt; class Ext extends Base {
     public Ext() throws Exception {
         throw new NullPointerException();
     }
 } &lt;/pre&gt;&lt;/p&gt;

&lt;p&gt; 所以牢记： &lt;em&gt;&lt;strong&gt;声明异常和实际抛出异常完全是两码事&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如 1. 所说，构造器的重写实际是调用关系，所以一旦默认构造器没有声明异常，那么其他构造器就可以随便添加异常声明 (Hint No.3 &amp;amp; Hint No.4)。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://erikyao.github.io/java/2009/08/04/exception-in-class-hierarchy</link>
                <guid>http://erikyao.github.io/java/2009/08/04/exception-in-class-hierarchy</guid>
                <pubDate>2009-08-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>finally总是会被执行</title>
                <description>&lt;p&gt;　　finally 总是会被执行，即使 try 中有break、continue、return 这样的语句，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class FinallyTest {  
    public static void main(String[] args) {  
        int i;  
          
        for (i = 0; ;i++) {  
            try {  
                if (i == 0) { 
                    continue;
                }
                else if (i == 1) {
                    break; 
                }
            } finally {  
                System.out.println(&quot;loop &quot; + i + &quot; ends&quot;);  
            }  
        }  
          
        try {  
            return;  
        } finally {  
            System.out.println(&quot;return ends&quot;);  
        }  
    }  
}  
  
// output  
/* 
    loop 0 ends 
    loop 1 ends 
    return ends 
*/  
&lt;/pre&gt;


&lt;p&gt;　　另外，从这个例子可以看出，不写 catch，直接 try-finally 也是可以的。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/08/03/finally-blocks-always-run</link>
                <guid>http://erikyao.github.io/java/2009/08/03/finally-blocks-always-run</guid>
                <pubDate>2009-08-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>first catch</title>
                <description>&lt;p&gt;　　try 块里有异常抛出时，程序会进入 &lt;em&gt;&lt;strong&gt;第一个&lt;/strong&gt;&lt;/em&gt; 异常类型匹配的 catch 块执行，其他的 catch 块不执行。&lt;/p&gt;

&lt;p&gt;　　注意这里说的 “第一个匹配的异常类型”。我们知道，所有的异常类型都是 extends Exception，所以 catch (Exception e) 可以 catch 所有的异常。&lt;/p&gt;

&lt;p&gt;　　同时，对基类异常的 catch 块会屏蔽其后的对其导出类异常的 catch 块，而且这个屏蔽只与 catch 块代码的位置有关系，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class MyException extends Exception {  
}  
  
public class ExceptionTest {  
    public static void main(String[] args) {  
        try {  
            throw new MyException();  
        } catch (Exception e) {  
            System.out.println(&quot;Catch an Exception: &quot; + e.getClass().toString());  
        } catch (MyException me) {  
            System.out.println(&quot;Catch a MyException: &quot; + me.getClass().toString());  
        }     
    }  
}  
  
// output: Compiling Error  
/* 已捕捉到异常 MyException */  
  
// when comment or delete the &#39;catch (MyException me)&#39; block  
// output:  
/* Catch an Exception: class MyException */  
&lt;/pre&gt;


&lt;p&gt;　　这里，catch (Exception e) 就屏蔽了 catch (MyException me)。但是，如果我们把 catch (MyException me) 置于 catch (Exception e) 之上，就不会有屏蔽。如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class MyException extends Exception {  
}  
  
public class ExceptionTest {  
    public static void main(String[] args) {  
        try {  
            throw new MyException();  
        } catch (MyException e) {  
            System.out.println(&quot;Catch a MyException: &quot; + e.getClass().toString());  
        } catch (Exception e) {  
            System.out.println(&quot;Catch an Exception: &quot; + e.getClass().toString());  
        }     
    }  
}  
  
// output:  
/* Catch a MyException: class MyException */  
&lt;/pre&gt;

</description>
                <link>http://erikyao.github.io/java/2009/07/31/first-catch</link>
                <guid>http://erikyao.github.io/java/2009/07/31/first-catch</guid>
                <pubDate>2009-07-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>foreach 与 iterable</title>
                <description>&lt;p&gt;　　Iterable 是一个接口，它只有一个方法 iterator()，要求返回一个 Iterator。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package java.lang;  
  
public interface Iterable&lt;T&gt; {  
    Iterator&lt;T&gt; iterator();  
} 
&lt;/pre&gt;


&lt;p&gt;　　而 Iterator 本身也是个接口，它有 hasNext()、next()、remove() 三个方法。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package java.util;  
  
public interface Iterator&lt;T&gt; {  
    boolean hasNext();  
    T       next();  
    void    remove(); //optional  
}  
&lt;/pre&gt;


&lt;p&gt;　　一般的实现为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
import java.util.*;  
  
public class StringArray implements Iterable&lt;String&gt; {  
    private String[] words;  
      
    public StringArray() {  
        words = &quot;This is the default sentence&quot;.split(&quot; &quot;);  
    }  
      
    public StringArray(String sentence) {  
        words = sentence.split(&quot; &quot;);  
    }  
      
    public Iterator&lt;String&gt; iterator() {  
        return new Iterator&lt;String&gt;() {  
            private int index = 0;  
              
            public boolean hasNext() {  
                return index &lt;= words.length - 1;  
            }  
              
            public String next() {  
                return words[index++];  
            }  
              
            public void remove() {  
                // we do not implement it here  
                throw new UnsupportedOperationException();  
            }  
        };  
    }  
      
    public static void main(String[] args) {  
        StringArray sa = new StringArray(&quot;Hello World&quot;);  
          
        for (String s : sa) {
            System.out.println(s);  
        }
    }  
}  

//output:  
/*   
    Hello    
    World 
*/ 
&lt;/pre&gt;


&lt;p&gt;　　目前有这么一个问题，如果一个类想要有不同的 Iterable 效果怎么办？我们可以使用不同的方法来返回不同的 Iterable 实现，而不是去实现 Iterable 接口。这样也是可以使用 foreach 语句的，因为 foreach 的语法要求就是 &lt;code&gt;for (Obj o : Iterable i)&lt;/code&gt;，不管是 StringArray implements Iterable&lt;String&gt; 或是 public Iterable&lt;String&gt; getIterable()，冒号后面放一个 Iterable 实现就好了，具体是什么形式并不限制。如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class ReverseStringArray {  
    private String[] words;  
      
    public ReverseStringArray() {
        words = &quot;This is the default sentence&quot;.split(&quot; &quot;);  
    }  
      
    public ReverseStringArray(String sentence) {
        words = sentence.split(&quot; &quot;);  
    }  
      
    public Iterable&lt;String&gt; reverseIterable() {
        return new Iterable&lt;String&gt;() {  
            public Iterator&lt;String&gt; iterator() {  
                return new Iterator&lt;String&gt;() {  
                    private int index = words.length - 1;  
                  
                    public boolean hasNext() {  
                        return index &gt;= 0;  
                    }  
                  
                    public String next() {  
                        return words[index--];  
                    }  
                      
                    public void remove() {  
                        // we do not implement it here  
                        throw new UnsupportedOperationException();  
                    }  
                };  
            }  
        };  
    }  
      
    public static void main(String[] args) {
        ReverseStringArray rsa = new ReverseStringArray(&quot;Hello World&quot;);  
          
        for (String s : rsa.reverseIterable()) { 
            System.out.println(s);
        }
    }  
}  
  
//output:  
/* 
    World 
    Hello 
*/  
&lt;/pre&gt;

</description>
                <link>http://erikyao.github.io/java/2009/07/30/foreach-and-iterable</link>
                <guid>http://erikyao.github.io/java/2009/07/30/foreach-and-iterable</guid>
                <pubDate>2009-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Arrays.asList()</title>
                <description>&lt;p&gt;　　Arrays.asList() 这个方法有点特殊，这里记录一下。&lt;/p&gt;

&lt;p&gt;　　首先，Arrays.asList() 返回的是一个 List 接口实现，这个 List 在底层是有数组实现的，所以 size 是 fixed 的。所以，下面的代码是不可以的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
List&lt;Integer&gt; list = Arrays.asList(1, 2, 3);  
list.add(4); // java.lang.UnsupportedOperationException
&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;2014-05-19补充&lt;/em&gt;：Arrays.asList() 返回的是 Arrays 自己定义的一个内部类 ArrayList，与我们常用的 ArrayList 是两个不同的类&lt;/p&gt;

&lt;p&gt;　　其次，如果不指定返回 List 的类型 (即&amp;lt;&gt;部分)的话，Arrays.asList() 对其返回 List 的类型有自己的判断，可以视为它自身的一种优化机制，如下所示：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
// Arrays.asList() makes its best guess about type.  
  
import java.util.*;  
  
class Snow {}  
  
class Powder extends Snow {}  
class Crusty extends Snow {}  
class Slush extends Snow {}  
  
class Light extends Powder {}  
class Heavy extends Powder {}  
  
public class AsListInference {  
    public static void main(String[] args) {  
        List&lt;Snow&gt; snow1 = Arrays.asList(new Crusty(), new Slush(), new Powder()); // pass  
  
        //List&lt;Snow&gt; snow2 = Arrays.asList(new Light(), new Heavy()); // error  
        List&lt;Powder&gt; snow2 = Arrays.asList(new Light(), new Heavy()); // pass  
          
        List&lt;Snow&gt; snow3 = Arrays.asList(new Light(), new Crusty()); // pass  
  
        List&lt;Snow&gt; snow4 = new ArrayList&lt;Snow&gt;();  
        Collections.addAll(snow4, new Light(), new Heavy()); // pass  
  
        List&lt;Snow&gt; snow5 = Arrays.&lt;Snow&gt;asList(new Light(), new Heavy()); // pass  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;　　snow1 添加3个 Snow 的导出类对象，没有问题。&lt;/p&gt;

&lt;p&gt;　　snow2 添加2个 Snow 的导出类对象，按理也是可以的，不过由于它们都是 Powder，所以 Arrays.asList() 返回的是一个 List&lt;Powder&gt;。可见 Arrays.asList() 返回的是精确类型的list。&lt;/p&gt;

&lt;p&gt;　　snow3 混合添加，也没有问题。&lt;/p&gt;

&lt;p&gt;　　snow4 不用 Arrays.asList()，使用 Collections.addAll()，就没有 snow2 中的局限了。&lt;/p&gt;

&lt;p&gt;　　如果一定要 Arrays.asList(new Light(), new Heavy()) 返回 List&lt;Snow&gt; 而不是 List&lt;Powder&gt;，可以用 &lt;code&gt;Arrays.&amp;lt;Snow&amp;gt;asList()&lt;/code&gt; 来强制产生 List&lt;Snow&gt;，如 snow5。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/07/28/arrays-aslist</link>
                <guid>http://erikyao.github.io/java/2009/07/28/arrays-aslist</guid>
                <pubDate>2009-07-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>proxy</title>
                <description>&lt;p&gt;　　类和类之间有3种关系：组合、继承和代理 (proxy)。&lt;/p&gt;

&lt;p&gt;　　组合即是一个类包含另一个类的对象作为自己的一个 field，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class A {  
    class B b = new B() ;  
    ......  
} 
&lt;/pre&gt;


&lt;p&gt;　　继承就不多说了。如果把接口看作 abstract class 的延伸的话，那么对接口的实现也可以看作继承。&lt;/p&gt;

&lt;p&gt;　　代理是组合的一种特殊形式。假设我们有上文的 class A 的对象 a，如果要用 class B 提供的接口时，一般是 a.b.method() 或是a.b.field。如果我们这里不想暴露 class B 的接口的话，该怎么办？这时就可以用到代理。简单地说，代理就是重新封装 class B 的接口，使其成为 class A 的接口。如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class A {  
    class B b = new B();  
  
    void method() {  
        b.method();  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;这样，客户端程序员在使用 class A 时，就不能接触到 class B 的接口了。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/04/07/proxy</link>
                <guid>http://erikyao.github.io/java/2009/04/07/proxy</guid>
                <pubDate>2009-04-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>关于继承的新认识：导出类调用基类方法其实是向上转型</title>
                <description>&lt;p&gt;　　前面对继承的理解常常用到了这么一用表述：Base的代码会被复制到Ext中。其实这么理解欠妥，看代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Base {  
    private String info = &quot;Here is Base&quot;;  
      
    public String getInfo() {  
        return info;  
    }  
}  
  
class Ext extends Base {  
    public static void main(String[] args) {  
        Ext e = new Ext();  
          
        System.out.println(e.getInfo());  
    }  
} 
&lt;/pre&gt;


&lt;p&gt;　　很明显，Base 的 private String info 是不能被继承的，所以就算 getInf() 的代码被复制到 Ext 中，Ext 也是无法调用的 getInfo() 的，因为 Ext 中没有 info 字段。所以 e.getInf() 其实隐藏了 e 的向上转型。&lt;/p&gt;

&lt;p&gt;　　所以我们至多只能说 getInfo() 被复制到 Ext 的方法列表里。&lt;/p&gt;

&lt;p&gt;　　当然，“复制说”还是很形象的，有助理解，细节方面自己知道就好。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/04/07/new-way-to-understand-extending</link>
                <guid>http://erikyao.github.io/java/2009/04/07/new-way-to-understand-extending</guid>
                <pubDate>2009-04-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>对内部类的继承</title>
                <description>&lt;p&gt;　　首先我们明确下 enclose 这个单词的逻辑关系：OuterClass encloses InnerClass，所以外部类就是 enclosing class，内部类是 enclosed class。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　如果一个一般类来继承内部类，需要在构造器中使用特殊的语法。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Outer {  
    class Inner {}  
}  
  
public class ExtInner extends Outer.Inner {  
    public ExtInner(Outer o) {  
        o.super();  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;　　ExtInner 的构造器必须要有一个 Outer 参数，然后调用 .super();。这里要求必须使用一个 &lt;code&gt;enclosingClassReference.super();&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;em&gt;题外话&lt;/em&gt;：你可能会问：在 ExtInner 的构造器里 return o.new Inner(); 行不行？编译器会告诉你：constructor 的 return-type 是 void。这个是本话题的意外收获。&lt;/p&gt;

&lt;p&gt;　　然后 ExtInner 中无法通过 Outer.this 来连接到外部类对象，在 ExtInner 中使用 Outer.this 会得到编译错误 “Outer 不是封闭类” (Java SE 1.5.0_15)，这里的封闭类应该就是 enclosing class 的意思，“Outer不是封闭类” 表示 Outer 并没有 enclose ExtInner，虽然 Outer 有 enclose Inner，且 ExtInner 继承自 Inner。&lt;/p&gt;

&lt;p&gt;　　如果 Base 有一个 Inner，然后 Ext 继承了 Base，这时 Ext 并没有继承 Base.Inner 的代码，即 Base.Inner 的代码没有复制到 Ext 中。此时，如果在 Ext 中也写一个 Inner，其实是不会发生冲突的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　如果内部类、外部类双重继承，情况如何呢？看下面代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class BaseOuter {  
    void print() {  
        System.out.println(&quot;BaseOuter prints&quot;);  
    }  
      
    class BaseInner {  
        void print2() {  
            System.out.println(&quot;BaseInner prints&quot;);  
        }  
          
        void print3() {  
            BaseOuter.this.print();  
        }  
    }  
}  
  
class ExtOuter extends BaseOuter {  
    void print4() {  
        System.out.println(&quot;ExtOuter prints&quot;);  
    }  
      
    class ExtInner extends BaseOuter.BaseInner {  
        void print5() {  
            System.out.println(&quot;ExtInner prints&quot;);  
        }  
          
        void print6() {  
            ExtOuter.this.print4();  
        }  
          
        void print7() {  
            BaseOuter.this.print(); // error: BaseOut is not the enclosing class  
        }  
    }  
}  
  
public class ExtInnerTest {  
    public static void main(String[] args) {  
        ExtOuter eo = new ExtOuter();  
        ExtOuter.ExtInner ei = eo.new ExtInner();  
          
        ei.print2();  
        ei.print3();  
        ei.print5();  
        ei.print6();  
        ei.print7(); // error: BaseOut is not the enclosing class  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;　　可以看到 ExtInner 可以通过向上转型变成 BaseInner，然后再连接到 BaseOut.this (ei.print3(); // OK)，但是不能直接使用 BaseOut.this (ei.print7(); // won&#39;t compile)。&lt;/p&gt;

&lt;p&gt;　　总结一点，内部类不能被外部类的导出类继承，外部类也不 enclose 内部类的导出类。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/04/07/extends-inner-class</link>
                <guid>http://erikyao.github.io/java/2009/04/07/extends-inner-class</guid>
                <pubDate>2009-04-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>static inner class</title>
                <description>&lt;p&gt;&lt;img src=&quot;https://t7tptw.bn1304.livefilestore.com/y2pPFxBADT-odssmefgALB16Td2xNL8fTJlfAgJLHvVqv_AqelAocuxgg39sxYaUpne05UmEDFArC17h-5bqM1zQQy6m1gULdaM5fb1i1NQBzI/1.png?psid=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　一般的内部类是不能有 static member 的，因为普通的内部类必须创建对象，不需要有 static member 只属于内部类本身，所以 static member 对普通内部类来说是没有意义也是不允许的。同样，static 内部类也是 static，所以一般的内部类中也不能有 static 内部类。&lt;/p&gt;

&lt;p&gt;　　static 内部类可以有 static member，由于 static 内部类对象的创建不需要外部类对象，所以 static 内部类是无法通过 Outer.this 来连接到外部类对象的。所以根据 &lt;a href=&quot;/java/2009/04/05/inner-class-this-and-new/&quot;&gt;内部类：对外部类的访问及 .this 和 .new&lt;/a&gt; 中关于内部类访问访问外部类 member 的说明，在 static 内部类中要访问外部类的 member 应该避免重名的现象发生。&lt;/p&gt;

&lt;p&gt;　　static 内部类表示这个内部类的定义是属于外部类的，但是 static 内部类的对象是可以有多个的，且可以直接创建。&lt;/p&gt;

&lt;p&gt;　　接口中允许有内部类存在，且接口中的内部类默认为 public + static，所以一定是 static 内部类。接口中的内部类可以实现这个接口本身。如果想要为接口创建公用代码，使得接口的不同实现都能使用这些代码，可以使用接口中的内部类。&lt;/p&gt;

&lt;p&gt;　　还有，可以使用 static 内部类来放置外部类的 main 测试方法。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/04/05/static-inner-class</link>
                <guid>http://erikyao.github.io/java/2009/04/05/static-inner-class</guid>
                <pubDate>2009-04-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>局部内部类 (local inner class)</title>
                <description>&lt;p&gt;　　如果把 &lt;code&gt;{...}&lt;/code&gt; 这么一段称为“域”，那么方法 body 明显是一个域，方法 body 中的 &lt;code&gt;if {}&lt;/code&gt; 或是 &lt;code&gt;for {}&lt;/code&gt; 之类的也是域。在方法 body 或是方法 body 中其他域里定义的类就是局部内部类。&lt;/p&gt;

&lt;p&gt;　　局部内部类 &lt;em&gt;&lt;strong&gt;只能&lt;/strong&gt;&lt;/em&gt; 在定义它的域中使用。且局部内部类的编译不受域执行与否的影响，即比如在 &lt;code&gt;if {}&lt;/code&gt; 中定义了一个局部内部类，即使这个 if 不执行，这个局部内部类也照常编译。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/04/05/local-inner-class</link>
                <guid>http://erikyao.github.io/java/2009/04/05/local-inner-class</guid>
                <pubDate>2009-04-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>内部类：对外部类的访问及 .this 和 .new</title>
                <description>

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Outer {   
    public class Inner {   
        public String getInnerClassName() {   
            return Inner.this.getClass().toString(); // &#39;Inner&#39; can be omitted here   
        }  
          
        public String getOuterClassName() {   
            return Outer.this.getClass().toString(); // &#39;Outer&#39; CANNOT be omitted here   
        }   
    }   
      
    public Inner createInner() {   
        return new Inner(); 
        // return this.new Inner(); // also OK here   
    }   
}   
  
public class InnerTest {   
    public static void main(String[] args) {   
        Outer o = new Outer();   
        Outer.Inner i1 = o.new Inner();   
        Outer.Inner i2 = o.createInner();   
          
        System.out.println(i1.getOuterClassName());   
        System.out.println(i2.getInnerClassName());   
    }   
}   
  
//output:   
/*  
    class Outer 
    class Outer$Inner  
*/  
&lt;/pre&gt;


&lt;h2&gt;.new&lt;/h2&gt;

&lt;p&gt;　　内部类对象是不能直接创建的。必须先创建一个外部类对象，再由这个外部类对象来创建内部类对象。这样处理可能是为了体现内部类对象是依存外部类对象存在的，即内部类对象不能脱离外部类对象而存在。一个外部类对象可以创建多个内部类对象 (类似 Process 与 Thread 的关系)。创建方法有2种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OuterClassObj.new InnerClass()：即使用 .new 和内部类构造器，如上面代码中的：
  &lt;pre class=&quot;prettyprint linenums&quot;&gt;
  Outer.Inner i1 = o.new Inner(); &lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;OuterClassObj.InnerClassConstructorProxy()：即使用在外部类中定义的内部类构造器的代理方法，如上面代码中的：
  &lt;pre class=&quot;prettyprint linenums&quot;&gt;
  Outer.Inner i2 = o.createInner(); &lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;上面2种方法其实是等价的。&lt;/p&gt;

&lt;p&gt;　　这里注意，内部类的声明类型必须是 Outer.Inner，编译出的文件为 Outer$Inner.class。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;.this　　&lt;/h2&gt;

&lt;p&gt;　　其实可以把 this 当作 class 的一个 static field，就算不用内部类，也可以照样用 class.this 形式，如上面代码中的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public String getInnerClassName() {   
    return Inner.this.getClass().toString(); // &#39;Inner&#39; can be omitted here   
}  
&lt;/pre&gt;


&lt;p&gt;　　不过鉴于内部类和外部类的特殊关系，内部类必须能够访问其创建者，所以在内部类中可以使用 Outer.this 来指向创建这个内部类对象的外部类对象。如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public String getOuterClassName() {   
    return Outer.this.getClass().toString(); //&#39;Outer&#39; CANNOT be omitted here   
}  
&lt;/pre&gt;


&lt;p&gt;　　总结一点，.this 与 class 连用 (class.this)，.new 与 reference 连用 (obj.new)。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;对外部类的field和method的访问　　&lt;/h2&gt;

&lt;p&gt;　　就如同我们在一般类的方法或是 constructor 中省略 this 一样，内部类的方法也是如此，只是内部类中省略的是 this (i.e. Inner.this) 和 Outer.this 这2个 this。所以 &lt;strong&gt;看上去&lt;/strong&gt; 在内部类的方法中可以直接访问外部类的 field/method，而且无论是哪种访问权限的 field/method 都可以访问，其实是因为内部类方法中可以通过 Outer.this 链接到外部类，由外部类来访问外部类的 field/method，自然是可以不考虑访问权限了。&lt;/p&gt;

&lt;p&gt;　　如果内部类和外部类有 &lt;em&gt;&lt;strong&gt;同名&lt;/strong&gt;&lt;/em&gt; 的 field/method，单纯使用 SameFieldName 或是 SameMethodName() &lt;em&gt;&lt;strong&gt;会被优先识别为内部类的&lt;/strong&gt;&lt;/em&gt; field/method，如果想要用外部类的 field/method，必须用 Outer.this 来指定。&lt;/p&gt;

&lt;p&gt;　　如果你手中只有内部类对象，比如 i1、i2，这样是无法直接访问外部类的 field/method 的，因为外部类的 field/method 并不属于内部类，类似 i1.OuterField 或是 i2.OuterMethod() 是无法通过编译的。所以 i1、i2 想要访问外部类的 field/method 只能间接通过内部类的方法。&lt;/p&gt;

&lt;p&gt;　　总之，简单的说，内部类对象要想访问外部类对象的 field 或是 method 的话，必须要先获得创建自己的外部类对象的引用。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/04/05/inner-class-this-and-new</link>
                <guid>http://erikyao.github.io/java/2009/04/05/inner-class-this-and-new</guid>
                <pubDate>2009-04-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>匿名内部类 (anonymous inner class)：简化形式及自动向上转型</title>
                <description>&lt;p&gt;　　内部类的一个重要作用是隐藏继承或是对接口的实现，典型的形式是：内部类来继承或是实现接口，由外部类提供代理 constructor 方法。这些代理 constructor 方法一般都利用的向上转型，即不返回内部类对象，而是返回内部类继承的父类对象或是实现的接口对象。如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
interface Intf {...}  
  
class Outer {  
    class Inner implements Intf {...}  
  
    public Intf createInner() {  
        return new Inner();  
    }  
} 
&lt;/pre&gt;


&lt;p&gt;　　而匿名内部类实际是对上述代码的简化，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
interface Intf {...}  
  
class Outer {  
    public Intf createInner() {  
        return new Intf() {...};  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;　　这里的匿名内部类表示：我要创建一个 implements Intf 的 class，这个 class 的定义是 {...}。由于这个 class 没有名字，我们用的是 new Intf()，可以看作是自动的向上转型。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2014-05-18补充&lt;/em&gt;：匿名内部类可以是继承，不一定是 new Intf()&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class InnerBase {  
    ...
}  
  
public class Outer {
    private InnerBase ib = new InnerBase() {
        @Override
        public String toString() {
            return &quot;whatever&quot;;
        }
    };
}
&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;4月7日补充&lt;/em&gt;：匿名内部类的另一种用法&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
interface Intf {  
    int sum();  
}  
  
public class Outer {  
    public static int getSum() {  
        return new Intf() {  
            public int sum() {  
                return 1;  
            }  
        }.sum();  
    }  
      
    public static void main(String[] args) {  
        System.out.println(getSum());  
    }  
} 
&lt;/pre&gt;


&lt;p&gt;　　因为对匿名内部类的使用是直接 new 一个匿名内部类对象，所以也可以直接使用这个对象的方法或是域。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;7月27日补充&lt;/em&gt;：匿名内部类的另一种用法&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
interface Intf {...}  
  
class Outer {  
    public Intf createInner() {  
        return new Intf() {  
            // Anonymous inner class CANNOT have a named constructor  
            // only an instance initializer here  
            {  
                ......  
            }  
  
            // method allowed here  
            return-type xxx(arg list) {  
                ......  
            }   
        };  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;匿名内部类没有构造器， &lt;strong&gt;只能&lt;/strong&gt; 有一个 initializer (当然，你不用也可以)；另外，可以在匿名内部类中写方法。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/04/05/anonymous-inner-class</link>
                <guid>http://erikyao.github.io/java/2009/04/05/anonymous-inner-class</guid>
                <pubDate>2009-04-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>entends interface</title>
                <description>&lt;p&gt;　　一个 imp class 可以同时实现多个 interface，格式如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Impl implements Intf1,  Intf2, ..., IntfN;
&lt;/pre&gt;


&lt;p&gt;　　如果一个 class 又有继承又有实现，那么应该先 extends 再 implements，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class ImplExt extends Base implements Intf;  
&lt;/pre&gt;


&lt;p&gt;　　
　　Java 中不支持 class 的多重继承，但 interface 可以，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Ext extends Base1, Base2, ..., BaseN; // syntax error  
interface ExtIntf extends BaseIntf1, BaseIntf2, ..., BaseIntfN; // OK 
&lt;/pre&gt;

</description>
                <link>http://erikyao.github.io/java/2009/04/03/entends-interface</link>
                <guid>http://erikyao.github.io/java/2009/04/03/entends-interface</guid>
                <pubDate>2009-04-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>interface</title>
                <description>&lt;p&gt;　　我们大可将 interface 视为 abstract class 的延伸。&lt;/p&gt;

&lt;p&gt;　　首先，interface 默认具有 abstract 属性，所以你不能 new 一个 interface。&lt;/p&gt;

&lt;p&gt;　　其次，interface 中的方法默认为 public。由 &lt;a href=&quot;/java/2009/04/02/accessibility-of-overridden-method/&quot;&gt;关于覆写方法的访问权限&lt;/a&gt; 可知，如果一个 imp class 实现了一个 interface (相当于一个 ext class 继承了一个 base class)，那么 imp class 中对 interface 中声明方法的实现 (相当于是覆写方法) 也必须是 public。&lt;/p&gt;

&lt;p&gt;　　再次，interface 中的 field 默认为 public + static + final，但不能为 blank final，即必须初始化。&lt;/p&gt;

&lt;p&gt;　　还有，和 abstract class 一样，interface 支持向上转型，即原来对一般 base class 的向上转型用法对 interface 同样适用。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;p.s.&lt;/em&gt; 如果 abstract class 或是 interface 声明为 public，则必须与 .java 文件同名，这一点与一般的 public class 无异。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2011-10-31补充&lt;/em&gt;：interface 中的方法你可以看成是 abstract，但是不能声明为 abstract&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2012-04-10补充&lt;/em&gt;：interface 中的方法不能是 static&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/04/02/interface</link>
                <guid>http://erikyao.github.io/java/2009/04/02/interface</guid>
                <pubDate>2009-04-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>关于覆写方法的访问权限</title>
                <description>&lt;p&gt;　　覆写方法的访问权限不得低于被覆写方法的访问权限（或者说覆写方法不能拥有比被覆写方法更严格的访问权限）。&lt;/p&gt;

&lt;p&gt;　　public &gt; protected &gt; package (default) &gt; private （private最严格，public最宽松）&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/04/02/accessibility-of-overridden-method</link>
                <guid>http://erikyao.github.io/java/2009/04/02/accessibility-of-overridden-method</guid>
                <pubDate>2009-04-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>abstract</title>
                <description>&lt;p&gt;　　abstract 的真正含义是“阻止产生对象” (针对类) 或是 “禁止被对象所拥有” (针对方法，类似static)。&lt;/p&gt;

&lt;p&gt;　　一个 abstract class 是不能产生 object 的（&lt;em&gt;P.S.&lt;/em&gt; 抽象类可以声明引用，不可实例化；类似在使用多态时，我们可以声明一个接口的引用，实际指向一个实现类对象）。&lt;/p&gt;

&lt;p&gt;　　abstract method 只有方法声明，没有方法 body。&lt;/p&gt;

&lt;p&gt;　　拥有 abstract method 的 class 必须声明为abstract class，否则会编译报错 (abstract method 不能被对象所拥有，那么包含该 abstract method 的 class 自然不能产生对象，所以必须是 abstract class)。当然，abstract class 不一定非要有 abstract method，在某些情况下，我们可能只是单纯地想要某个 class 不能产生对象，这时就可以用 abstract class，对这个 abstract clas s的内部我们没有任何要求。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;P.S.&lt;/em&gt; 编译器对 abstract 和后面要提到的 interface 的处理机制都是 Java 为了强调抽象的设计方法而在语言方面做的强制规定&lt;/p&gt;

&lt;p&gt;　　因为 abstract class 不能产生 object，所以主要用来继承。如果一个 ext class 继承自 abstract class，且该 abstract class 中有 abstract method，那么由继承的知识可知，ext class 也会有这个abstract method，如果 ext class 中不覆写这个 abstract method，那么这个 ext class 也必须声明为 abstract。&lt;/p&gt;

&lt;p&gt;　　abstract class 作为 base class 是支持向上转型的，即原来对一般 base class 的向上转型用法对 abstract base class 同样适用&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/04/02/abstract</link>
                <guid>http://erikyao.github.io/java/2009/04/02/abstract</guid>
                <pubDate>2009-04-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>warning: 在构造器中请谨慎使用被覆写方法</title>
                <description>&lt;p&gt;先上代码 (adapted from &lt;em&gt;Chapter 8, Thinking in Java, Fourth Edition&lt;/em&gt;)：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Glyph {  
    void draw() {   
        System.out.println(&quot;Glyph.draw()&quot;);  
    }  
      
    Glyph() {  
        System.out.println(&quot;Glyph constructor&quot;);  
        draw();  
    }  
}     
  
class RoundGlyph extends Glyph {  
    private int radius = 1;  
  
    RoundGlyph(int r) {  
        System.out.println(&quot;before assignment in constructor, radius = &quot; + radius);  
        radius = r;  
        System.out.println(&quot;RoundGlyph constructor, radius = &quot; + radius);  
    }  
      
    void draw() {  
        System.out.println(&quot;RoundGlyph.draw(), radius = &quot; + radius);  
    }  
}     
  
public class PolyConstructors {  
    public static void main(String[] args) {  
        new RoundGlyph(5);  
    }  
}  
//Output:  
/* 
    Glyph constructor 
    RoundGlyph.draw(), radius = 0 
    before assignment in constructor, radius = 1 
    RoundGlyph constructor, radius = 5 
*/ 
&lt;/pre&gt;


&lt;p&gt;　　根据 &lt;a href=&quot;/java/2009/03/25/class-loading-an-example/&quot;&gt;class loading: an example&lt;/a&gt;，调用 RoundGlyph 的构造器时，会先调用 Glyph 的构造器。Glyph 的构造器里调用了一个被覆写方法 draw()。这里我们惊奇地发现：虽然 RoundGlyph 对象还没有创建完毕，但 Glyph 的构造器却实际调用了 RoundGlyph 的 draw() 方法 (覆写方法)，而且 radius == 0。&lt;/p&gt;

&lt;p&gt;　　而 JVM-Spec $2.17.6 Creation of New Class Instances 最后一段有：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If methods are invoked that are overridden in subclasses in the object being initialized, then these overriding methods are used, even before the new object is completely created.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　由此，我们可以对 &lt;a href=&quot;/java/2009/03/25/class-loading-an-example/&quot;&gt;class loading: an example&lt;/a&gt; 做一些补充，即在调用 ext class 的 constructor 时，会有如下的过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将分配给该 ext class object 的内存空间全部初始化为 0x00 (即用 0x00 填满该段内存空间)；&lt;/li&gt;
&lt;li&gt;调用 base class 的 constructor。如果 base class 的 constructor 有使用被覆写方法的话，则实际调用 ext class 中的覆写方法。由于上一个步骤的原因，此时 ext class 中各 field 均为0；&lt;/li&gt;
&lt;li&gt;base class 的 constructor 调用完毕后后，开始初始化 (包括默认初始化) ext class 的 member；&lt;/li&gt;
&lt;li&gt;调用 ext class 的 constructor。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2009年09月04日归纳&lt;/em&gt;：&lt;a href=&quot;/java/2009/09/04/class-loading-further-discussion-involving-steps-of-instance-creation/&quot;&gt;class loading: further discussion involving steps of instance creation&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/27/using-overridden-method-in-constructor-is-dangerous</link>
                <guid>http://erikyao.github.io/java/2009/03/27/using-overridden-method-in-constructor-is-dangerous</guid>
                <pubDate>2009-03-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>关于覆写方法的 return type</title>
                <description>&lt;p&gt;　　在 &lt;a href=&quot;/java/2009/03/23/overload-and-override/&quot;&gt;overload and override: 重载与覆写&lt;/a&gt; 里面提到过，如果在 base class 中有一个可继承的方法，在 ext class 中添加一个同签名的方法则是覆写行为。其实，覆写对 return type 还是有要求的。&lt;/p&gt;

&lt;p&gt;　　一般说来，覆写方法要求除了签名相同外，return type 也要相同。&lt;/p&gt;

&lt;p&gt;　　另外，Java SE 5新推出了“协变返回类型(covariant return type)”，即覆写方法的 return type 可以是被覆写方法 return type 的 ext class，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class BaseReturnType {  
}  
  
class ExtReturnType extends BaseReturnType {  
}  
  
class Base {  
    BaseReturnType work() {  
        return new BaseReturnType();  
    }  
}  
  
class Ext extends Base {  
    ExtReturnType work() {  
        return new ExtReturnType();  
    }  
} 
&lt;/pre&gt;


&lt;p&gt;&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/27/return-type-of-overridden-method</link>
                <guid>http://erikyao.github.io/java/2009/03/27/return-type-of-overridden-method</guid>
                <pubDate>2009-03-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>多态</title>
                <description>&lt;h2&gt;1. 向上转型 (upcast)&lt;/h2&gt;

&lt;p&gt;　　一个 ext class 的 object 可以用 base class 的 reference 来指向，即 ext class 的 object reference 可以升级为 base class 的 object reference。&lt;/p&gt;

&lt;p&gt;　　如：&lt;code&gt;Base b = new Ext();&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;2. 动态绑定 (dynamic binding)&lt;/h2&gt;

&lt;p&gt;　　一般说来，将一个方法调用和一个方法主体关联起来叫做绑定。也可以理解为将方法名和方法 body (方法代码段) 关联起来叫做绑定。除了 static 方法和 final 方法 (final 包含 private) 外，Java 对其他所有的方法都采用 dynamic binding (&lt;em&gt;3月27日补充&lt;/em&gt;：请正确理解这句话；more details see &lt;a href=&quot;/java/2009/03/27/more-on-downcast-and-dynamic-binding/&quot;&gt;有关向下转型的必要性和动态绑定的细节&lt;/a&gt;)，即直到调用方法的那个时刻才开始绑定。&lt;/p&gt;

&lt;p&gt;　　多态即是利用了动态绑定这一特点。举个例子来说，Base 类有个 work() 方法，Base 类的两个子类 Ext1 和 Ext2 都覆写了 work() 方法，现在有一个 Base b，它可能是一个 new Base()，也可能是一个 new Ext1()或是 new Ext2() (向上转型允许)，若此时调用 b.work()，编译器会判断究竟是调用 Base 类的 work() 还是 Ext1 类的 work() 或是 Ext2 类的 work()。从这个角度来说，动态绑定更像是动态确定 reference 指向的 object，即这个 reference 到底是指向 Base object 还是 Ext1 object 或是 Ext2 object。&lt;/p&gt;

&lt;p&gt;　　注意，Ext1 和 Ext2 必须是都覆写了 work() 方法，如果不是覆写就没有动态绑定的意义了，因为只有覆写才能造成 Base、Ext1、Ext2 中各有一个同签名不同方法 body 的 work() 方法。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;p.s.&lt;/em&gt; 不存在平行转型 (horizontal-cast)，即 Ext1 e = new Ext2()。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;3. field 和 static 方法没有动态绑定&lt;/h2&gt;

&lt;p&gt;　　意味着 b.field 和 b.staticMethod()完全看 b 的声明类型。若是声明了 Ext b，则是 Ext 的 field 和 staticMethod()；若是声明了 Base b，则是 Base 的 field 和 staticMethod()，就算有 Base b = new Ext(); 也是如此。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;4. 利用多态的一个例子&lt;/h2&gt;

&lt;p&gt;　　如在某方法中，不管传进来的参数是 Ext1 object 还是 Ext2 object，都要求执行 work() 方法，这是可以写成：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
return-type xxx(..., Base b, ...) {  
    ...;  
    b.work();  
    ...;  
}  
&lt;/pre&gt;


&lt;p&gt;这就相当于把类型判断交给编译器去执行了。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/27/polymorphism</link>
                <guid>http://erikyao.github.io/java/2009/03/27/polymorphism</guid>
                <pubDate>2009-03-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>有关向下转型的必要性和动态绑定的细节</title>
                <description>&lt;p&gt;　　在 &lt;a href=&quot;/java/2009/03/27/polymorphism/&quot;&gt;多态&lt;/a&gt; 里面说过：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;除了 static 方法和 final 方法 (final 包含 private) 外，Java 对其他所有的方法都采用 dynamic binding&lt;/p&gt;

&lt;p&gt;&lt;em&gt;P151, Chapter 8, Thinking in Java, Fourth Edition&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;不过下面的这个例子也许会让人有点吃惊 (also from &lt;em&gt;Chapter 8, Thinking in Java, Fourth Edition&lt;/em&gt;)：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
//RTTI: Run-Time Type Identification  
  
class Useful {  
    public void f() {System.out.println(&quot;Useful.f()&quot;);}  
}  
  
class MoreUseful extends Useful {  
    public void f() {System.out.println(&quot;MoreUseful.f()&quot;);}  
    public void g() {System.out.println(&quot;MoreUseful.g()&quot;);}  
}     
  
public class RTTI {  
    public static void main(String[] args) {  
        Useful x = new MoreUseful();  
          
        x.f();  
        //x.g(); // 编译错误：找不到符号  
        ((MoreUseful)x).g(); // OK. This is Downcast/RTTI  
    }  
}  
//output:  
/* 
    MoreUseful.f() 
    MoreUseful.g() 
*/
&lt;/pre&gt;


&lt;p&gt;　　按理来说，x.f() 通过动态绑定能够正确调用 MoreUseful 的 f() 方法，那么为什么 x.g() 就不行呢？真的是“除了 static 方法和 final 方法 (final 包含 private) 外，Java 对其他 &lt;em&gt;&lt;strong&gt;‘所有’&lt;/strong&gt;&lt;/em&gt; 的方法都采用 dynamic binding”吗？还是只对覆写方法才动态绑定？&lt;/p&gt;

&lt;p&gt;　　其实这里涉及到动态绑定的细节问题。当然，的确是 “除了 static 方法和 final 方法 (final 包含 private) 外，Java 对其他所有的方法都采用 dynamic binding”，只不过在使用动态绑定之前，编译器还做了一些其他的工作，而这些工作，就是造成上面代码结果的原因。&lt;/p&gt;

&lt;p&gt;　　Java的方法调用过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编译器查看引用 (x) 的声明类型 (Useful) 和方法名 (g())；通过声明类型找到方法列表；

&lt;ul&gt;
&lt;li&gt;如果方法名不在方法列表中，则编译器报错 (g() 不在 Useful 的方法列表里，所以出错)；&lt;/li&gt;
&lt;li&gt;如果方法名在方法列表中，则继续下列步骤；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;编译器查看方法的参数列表，获取参数方法签名；

&lt;ul&gt;
&lt;li&gt;如果方法是 private、static、final 或者构造器，编译器就可以确定调用那个方法 (这是静态绑定)；&lt;/li&gt;
&lt;li&gt;如果不是上述情况，就要使用动态绑定；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;　　可见，x.g() 出错是由于使用动态绑定前的方法名检查未通过。从这个角度来说，动态绑定似乎的确只适用于覆写方法。&lt;/p&gt;

&lt;p&gt;　　由于无法使用动态绑定，所以要正确调用 x.g() 方法，向下转型 ((MoreUseful)x) 就必不可少了。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/27/more-on-downcast-and-dynamic-binding</link>
                <guid>http://erikyao.github.io/java/2009/03/27/more-on-downcast-and-dynamic-binding</guid>
                <pubDate>2009-03-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>final</title>
                <description>&lt;h2&gt;final data (基本数据类型)&lt;/h2&gt;

&lt;p&gt;　　相当于const&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;final reference&lt;/h2&gt;

&lt;p&gt;　　意味着该引用被绑定到一个具体对象，即该引用不能再指向另外一个对象。&lt;/p&gt;

&lt;p&gt;　　但这个被指向的对象本身是可以发生变化的。&lt;/p&gt;

&lt;p&gt; &lt;em&gt;P.S.&lt;/em&gt; final data 和 final reference 必须在定义处或是构造器中初始化（注意：这里说的“必须在定义处或是构造器中初始化”指的是类的 final member，即 final 成员。如果在方法中定义 final data 或 final reference，则没有这个限制）。所谓 blank final (我谓之 dynamic final)，即是先声明 final data 或是 final reference，不在定义处初始化而是根据具体情况灵活地在构造器中初始化。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;P.S.&lt;/em&gt; 参考 &lt;a href=&quot;/java/2010/07/04/pass-by-value-in-java/&quot;&gt;Java的值传递&lt;/a&gt; ，final data 和 final reference 可以理解为：final 保证栈上的值不可修改&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;final method&lt;/h2&gt;

&lt;p&gt;　　final method 可以继承，可以重载，不可覆写。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;final class&lt;/h2&gt;

&lt;p&gt;　　final class 不可继承&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/25/final</link>
                <guid>http://erikyao.github.io/java/2009/03/25/final</guid>
                <pubDate>2009-03-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>class loading: an example</title>
                <description>&lt;p&gt;　　class loading 是一个比较复杂的过程。一般说来，类是在其 static member 被访问时被加载的。在加载时会做的一件事是：初始化 static member 和 static 代码段 (static block, i.e. static {......})，当然，static 是只会被执行 only once 的。&lt;/p&gt;

&lt;p&gt;　　以下是一个例子 (adapted from &lt;em&gt;Chapter 7, Thinking in Java, Fourth Edition&lt;/em&gt;)：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
import static java.lang.System.out;  
  
class Insect {  
    private int i = 1;  
    protected int j;  
    private static int x1 = printInit(&quot;static Insect.x1 initialized&quot;);  
      
    Insect() {  
        out.println(&quot;Insect constructor&quot;);  
        out.println(&quot;i = &quot; + i + &quot;, j = &quot; + j + &quot;, x1 = &quot; + x1);  
        this.j = 2;  
    }  
      
    static int printInit(String s) {  
        out.println(s);  
  
        return 3;  
    }  
}  
  
public class Beetle extends Insect {  
    private int k = printInit(&quot;Beetle.k initialized&quot;);  
    private static int x2 = printInit(&quot;static Beetle.x2 initialized&quot;);  
      
    public Beetle() {  
        out.println(&quot;Beetle constructor&quot;);  
        out.println(&quot;j = &quot; + j + &quot;, k = &quot; + k + &quot;, x2 = &quot; + x2);  
    }  
   
    public static void main(String[] args) {  
        Beetle b = new Beetle();  
    }  
}  
//output:  
/* 
    static Insect.x1 initialized 
    static Beetle.x2 initialized 
    Insect constructor 
    i = 1, j = 0, x1 = 3 
    Beetle.k initialized 
    Beetle constructor 
    j = 2, k = 3, x2 = 3 
*/ 
&lt;/pre&gt;


&lt;ol&gt;
&lt;li&gt;首先，访问Beetle.main()，是个 static，好，加载 Beetle.class；

&lt;ul&gt;
&lt;li&gt;发现Beetle extends Insect，好，加载 Insect.class (如果 Insect 还有 base class，则持续这一过程，直到找到 root base class)；

&lt;ul&gt;
&lt;li&gt;初始化 private static int x1( = 3)，打印 &quot;static Insect.x1 initialized&quot;；&lt;/li&gt;
&lt;li&gt;Insect.class 加载完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;继续加载 Beetle.class；

&lt;ul&gt;
&lt;li&gt;初始化private static int x2( = 3)，打印&quot;static Beetle.x2 initialized&quot;；&lt;/li&gt;
&lt;li&gt;Beetle.class 加载完毕，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开始执行 Beetle.main()；

&lt;ul&gt;
&lt;li&gt;要 new 一个 Beetle，须先 new 一个 Insect；

&lt;ul&gt;
&lt;li&gt;在执行 Insect constructor 前，先要初始化 member，由于 private static int x1 是 static 且已经初始化了，所以这次只初始化 private int i( = 1) 和 protected int j( = 0 by default)；&lt;/li&gt;
&lt;li&gt;执行 Insect constructor，打印 &quot;Insect constructor&quot; 和 &quot;i = 1, j = 0, x1 = 3&quot;，然后 j = 2；&lt;/li&gt;
&lt;li&gt;Insect constructor 执行完毕，即 new Insect 过程完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;继续 new Beetle；

&lt;ul&gt;
&lt;li&gt;同理，在执行 Beetle constructor 之前，要先初始化 member，这里是初始化 private int k( = 3)，打印 &quot;Beetle.k initialized&quot;；&lt;/li&gt;
&lt;li&gt;执行 Beetle constructor，打印 &quot;Beetle constructor&quot; 和 &quot;j = 2, k = 3, x2 = 3&quot;；&lt;/li&gt;
&lt;li&gt;Beetle constructor 执行完毕，即 new Beetle 过程完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Beetle.main() 执行完毕。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2009年03月27日补充&lt;/em&gt;：more details see &lt;a href=&quot;/java/2009/03/27/using-overridden-method-in-constructor-is-dangerous/&quot;&gt;warning: 在构造器中请谨慎使用被覆写方法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2009年09月04日归纳&lt;/em&gt;：&lt;a href=&quot;/java/2009/09/04/class-loading-further-discussion-involving-steps-of-instance-creation/&quot;&gt;class loading: further discussion involving steps of instance creation&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/25/class-loading-an-example</link>
                <guid>http://erikyao.github.io/java/2009/03/25/class-loading-an-example</guid>
                <pubDate>2009-03-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>private、package 权限字段不可继承</title>
                <description>&lt;p&gt;　　base class 的 private member 是不可继承的(详细请参见 &lt;a href=&quot;/java/2009/03/19/accessibility-of-class-and-class-member/&quot;&gt;关于class和class member的访问权限&lt;/a&gt;)，所以在 ext class 中也不会有这些 member。&lt;/p&gt;

&lt;p&gt;　　可以这样理解：ext class 隐式包含一个 base class，base class 根据 member 的访问权限决定是否将 member 暴露给 ext class。&lt;/p&gt;

&lt;p&gt;　　不过 ext class 可以通过 base class 的非 private getter 来 access 这些 private member。&lt;/p&gt;

&lt;p&gt;　　package权限字段不可继承的理由同。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/23/private-and-package-members-is-not-inheritable</link>
                <guid>http://erikyao.github.io/java/2009/03/23/private-and-package-members-is-not-inheritable</guid>
                <pubDate>2009-03-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>overload and override: 重载与覆写</title>
                <description>&lt;p&gt;　　overload: 重载，指在同一个 class 中有多个 &lt;strong&gt;同名&lt;/strong&gt; function 的现象。&lt;/p&gt;

&lt;p&gt;　　override: 覆写，指 ext class 中重写base class中的 &lt;strong&gt;同签名&lt;/strong&gt; function 的行为。&lt;/p&gt;

&lt;p&gt;　　注意，如果 ext class 继承了 base class ——假设 base class 中一个 &lt;strong&gt;非private非final的&lt;/strong&gt; work(arg list 1)方法—— ext class 中同样也会有 work(arg list 1) 方法。&lt;/p&gt;

&lt;p&gt;　　此时如果在 ext class 中再添加一个同名 function，如 work(arg list 2)，则是重载行为。&lt;/p&gt;

&lt;p&gt;　　如果添加一个同签名 function，即work(arg list 1)，则是覆写行为。&lt;/p&gt;

&lt;p&gt;　　方法名与参数列表合称方法签名，是方法的唯一标识。return type不属于方法签名。(3月27日补充：虽然如此，覆写对return type还是有要求的，more details see &lt;a href=&quot;/java/2014/05/17/return-type-of-overridden-method/&quot;&gt;关于覆写方法的return type&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;　　如果base class中的work(arg list 1)方法是private或是final的，那么ext class中是不会有work(arg list 1)方法的，所以无论是添加work(arg list 1)方法或是work(arg list 2)方法，是既不算重载也不算覆写的。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;P.S.&lt;/em&gt; 重载并不要求有继承，同一个类中也可以有重载行为&lt;/p&gt;

&lt;p&gt;&lt;em&gt;P.S.&lt;/em&gt; 静态方法没有覆写机制，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Base {  
    public static void print() {  
        System.out.println(&quot;Base prints.&quot;);  
    }  
}  
  
public class Ext extends Base {  
    public static void print() {  
        System.out.println(&quot;Ext prints.&quot;);  
    }  
      
    public static void main(String[] args) {          
        Base.print(); // Base prints.  
        Ext.print(); // Ext prints.  
          
        Base b = new Base();  
        b.print(); // Base prints.  
          
        Base b2 = new Ext();  
        b2.print(); // Base prints.  
          
        Ext e = new Ext();  
        e.print(); // Ext prints.  
    }  
}  
&lt;/pre&gt;


&lt;p&gt;尤其需要注意的是 b2，这里不像多态机制，静态方法的绑定也是静态的，引用是啥类型，就调用啥类型的静态方法。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/23/overload-and-override</link>
                <guid>http://erikyao.github.io/java/2009/03/23/overload-and-override</guid>
                <pubDate>2009-03-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>initializer</title>
                <description>&lt;p&gt;　　A block-formed initializer can be appended after the fields declared.&lt;/p&gt;

&lt;p&gt;　　If the fields are static, the initializer can also be static too, which means it&#39;s only executed once. If the initializer is not static, it will be executed as many times as the class constructor will be, even if the fields are static.&lt;/p&gt;

&lt;p&gt;　　The non-static fields can not be initialized in a static intializer.&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Book {     
    Book(int id) {     
        System.out.println(&quot;This is book No.&quot; + id);     
    }     
}     
    
class Bookshelf {     
    // case 1:     
    /**   
    Book b1;   
    Book b2;    
    {   
        b1 = new Book(1);   
        b2 = new Book(2);   
    }   
    */    
    //output:     
    //This is book No.1     
    //This is book No.2     
    //This is book No.1     
    //This is book No.2     
    
    //case 2:     
    static Book b1;     
    static Book b2;     
    static      
    {     
        b1 = new Book(1);     
        b2 = new Book(2);     
    }     
    //output:     
    //This is book No.1     
    //This is book No.2     
    
    //case 3:     
    /**   
    static Book b1;   
    static Book b2;   
    {   
        b1 = new Book(1);   
        b2 = new Book(2);   
    }   
    */    
    //output:     
    //This is book No.1     
    //This is book No.2     
    //This is book No.1     
    //This is book No.2     
    
    //case 4:     
    /**   
    Book b1;   
    Book b2;   
    static    
    {   
        b1 = new Book(1);   
        b2 = new Book(2);   
    }   
    */    
    //output: error     
}     
    
class InitBlockTest {     
    public static void main(String[] arg) {     
        new Bookshelf();     
        new Bookshelf();     
    }     
}
&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;9月4号补充:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　initializer 不一定非要是初始化成员，在 initializer 内部其实是可以随便写的，像这样也可以：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Test {  
    //static  
    {  
        System.out.println(&quot;pass&quot;);  
    }  
}  
  
public class InitializerTest {  
    public static void main(String[] args) {  
        new Test();  
        new Test();  
    }  
}  
  
//output  
/* 
    pass 
    pass 
*/ 
&lt;/pre&gt;


&lt;p&gt;　　另：在声明 field 的时候，常常会当场初始化 field，这个称为 variable intializer (更倾向于将声明 field 的表达式右值称为 variable initializer)。根据 field 是否 static 及初始化是否调用了 static 方法，variable initializer 有的属于 class 行为，有的属于 object 行为。static initializer 完全属于 class 行为。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2009年09月04日归纳&lt;/em&gt;：&lt;a href=&quot;/java/2009/09/04/class-loading-further-discussion-involving-steps-of-instance-creation/&quot;&gt;class loading: further discussion involving steps of instance creation&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/19/initializer</link>
                <guid>http://erikyao.github.io/java/2009/03/19/initializer</guid>
                <pubDate>2009-03-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>关于 class 和 class member 的访问权限</title>
                <description>&lt;h2&gt;class的访问权限&lt;/h2&gt;

&lt;p&gt;　　class的访问权限只有public和package两种，不存在private和protected（内部类是特例）。&lt;/p&gt;

&lt;p&gt;　　每一个编译单元（即.java文件）至多只能有一个public class，且如果有的话，该public class名必须与文件名相同。&lt;/p&gt;

&lt;p&gt;　　class访问权限是member访问权限的基础。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;member的访问权限&lt;/h2&gt;

&lt;p&gt;　　当一个class是可访问的时候，member的访问权限才有意义。&lt;/p&gt;

&lt;p&gt;　　private、package、protected、public，具体的就不详细说了。&lt;/p&gt;

&lt;p&gt;　　protected包含package权限。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;em&gt;7月27日补充：member的访问权限是针对类而言的&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　public: 对所有类可见。&lt;/p&gt;

&lt;p&gt;　　protectd: 对其Ext Class可见 + package。&lt;/p&gt;

&lt;p&gt;　　package: 对同一pkg内的类可见。&lt;/p&gt;

&lt;p&gt;　　private: 仅对member所在的类可见。&lt;/p&gt;

&lt;p&gt;　　我们这里说的都是Class，而不是Object。有时候在理解上会有这样的混淆：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
class Test {  
    private int i;  
}  
  
public class PrivateTest {  
    public static void main(String[] args) {  
        Test t = new Test();  
        System.out.println(&quot;i = &quot; + t.i); // syntax error  
    }  
} 
&lt;/pre&gt;


&lt;p&gt;　　我们的确是获得了 Test 对象 t，i 也的确是 t 的 member，不过我们访问 i 是在 PrivateTest 类中，根据 private 的定义，这里依旧是会出错。&lt;/p&gt;

&lt;p&gt;　　所以说，member 的访问权限是针对类而言的，而不是针对对象。不能单纯地以为只要获得了对象(引用)，就能随便访问对象中的所有成员。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;em&gt;10月10日补充：可见的意思&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　如果类 A 的字段 i 对类 B 可见，则在类 B 中可以通过类的对象引用（假设有&lt;code&gt;A a = new A();&lt;/code&gt;）（如果是 static 字段，则是通过类名）来访问字段 i，即：可以在类B中直接写 a.i（如果是 static 字段，则是可以写A.i）。&lt;/p&gt;

&lt;p&gt;　　那么，我们现在回头看，如果类 A 的字段 i 是：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Accessibility  &lt;/th&gt;
&lt;th&gt;  Comment&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;public: 对所有类可见 &lt;/td&gt;
&lt;td&gt; 所有的类中都可以写 a.i 或是 A.i&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;protectd: 对其Ext Class可见 + package &lt;/td&gt;
&lt;td&gt; 只有与类 A 同包的类，或是类 A 的子类中可以写 a.i 或是 A.i&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;package: 对同一pkg内的类可见 &lt;/td&gt;
&lt;td&gt; 只有与类 A 同包的类中可以写 a.i或是 A.i&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;private: 仅对member所在的类可见 &lt;/td&gt;
&lt;td&gt; 只有类 A 本身可以直接用 a.i或是 A.i&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;　　这里又涉及到另外一个问题，即我自己常用的表达：private、package 不可继承。其实这里 private、package 权限字段是由于对子类不可见所以不能继承。可以理解为 ext class 隐式包含一个 base class，base class 根据 member 的访问权限决定是否将 member 暴露给 ext class。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/19/accessibility-of-class-and-class-member</link>
                <guid>http://erikyao.github.io/java/2009/03/19/accessibility-of-class-and-class-member</guid>
                <pubDate>2009-03-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>static</title>
                <description>&lt;h2&gt;static member / field / method&lt;/h2&gt;

&lt;p&gt;　　每 new 一个 object 即相当于申请了一块内存，用来存放这个 object 的 member/field/method。两个 object 的 member/field 不尽相同，同时也许因为如此，导致两个 object 的 method 不尽相同，从而这两个 object 要占据两块内存，而且它们之间没有共享 member/field/method。&lt;/p&gt;

&lt;p&gt;　　如果有 field/member/method 只与 class 有关，即不会在不同的 object 中有不同的值或操作，亦即在所有的 object 中表现都一样，可以将其设置为 static。可以将 static member/field/method 理解为归 class 所有，即存在于 class 的内存块中，而不是在 object 的内存块中。&lt;/p&gt;

&lt;p&gt;　　在调用时，可以直接使用 class.staticMember/staticField/staticMethod，当然，用 object.staticMember/staticField/staticMethod 也行，但这样无法体现 member/field/method 的 static 性。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;static import&lt;/h2&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
// 精确导入方式：
// import 最后只用写出成员名，就算是 method，也不用写出括号或是参数列表。
import static pkg.class/interface.staticMember;  
&lt;/pre&gt;




&lt;pre class=&quot;prettyprint linenums&quot;&gt;
// 模糊导入方式：
// 这样可以将 class/interface 中的 staticMember 静态导入，在后面的代码中就不用写 class/interface.staticMember 这么麻烦，直接写 staticMember 了事。
// 如果是 field 就直接写 staticField，不用写 class/interface.staticField；
// 如果是 method 就直接写 staticMethod()，不用写 class/interface.staticMethod()。
import static pkg.class/interface.*;  
&lt;/pre&gt;


&lt;p&gt;　　例如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
import static java.lang.System.out;  
&lt;/pre&gt;


&lt;p&gt;　　之后就可以直接写 out.println()，不用写 System.out.println()。注意，这里 out 才是 static member，println 是 out 的方法，且不是 static，所以不能直接写 println()。&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/java/2009/03/18/static</link>
                <guid>http://erikyao.github.io/java/2009/03/18/static</guid>
                <pubDate>2009-03-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>array reference and initialization</title>
                <description>&lt;h2&gt;array reference&lt;/h2&gt;

&lt;p&gt;　　可以用这么一种观点审视数组：数组其实是一个特殊的类，我们在声明数组时得到的是数组对象的引用。&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
int[] a; // 得到的 a 是 int[] 对象的一个引用
int[5] a; //syntax error
&lt;/pre&gt;


&lt;p&gt;　　从引用的角度来说，声明引用时也没必要知道 int[] 的 length：那是 int[] 对象的事情，与引用本身没有关系。&lt;/p&gt;

&lt;p&gt;　　还有一种形式可以用来声明数组引用，但不能直接接上初始化:&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
int[] c = new int[x]; // x 可以是变量、常量、magic number、表达式……只要能产生一个 value 即可  
int[] d = new int[x] {……}; // syntax error
&lt;/pre&gt;


&lt;p&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;initialization of an array&lt;/h2&gt;

&lt;p&gt;　　数组的初始化只能通过 {...} 来进行，有2种方式：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
int[] a = {1, 2, 3};  
int[] b = new int[] {1, 2, 3};  
&lt;/pre&gt;


&lt;p&gt;　　其中 new int[] {...} 形式可以像 new Object() 一样可以传递给方法作参数，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
method(new int[] {1, 2});  
&lt;/pre&gt;

</description>
                <link>http://erikyao.github.io/java/2009/03/18/array-reference-and-initialization</link>
                <guid>http://erikyao.github.io/java/2009/03/18/array-reference-and-initialization</guid>
                <pubDate>2009-03-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ARM7 学习笔记</title>
                <description>&lt;h2&gt;1．MEMMAP&lt;/h2&gt;

&lt;p&gt;MEMMAP = 0x00时为Boot模式，异常向量表从Boot Block重新映射&lt;/p&gt;

&lt;p&gt;MEMMAP = 0x01时为片内Flash模式，异常向量表不重新映射&lt;/p&gt;

&lt;p&gt;MEMMAP = 0x10时为片内RAM模式，异常向量表从静态RAM重新映射&lt;/p&gt;

&lt;p&gt;MEMMAP = 0x11时为片外存储器模式，异常向量表从外部存储器重新映射(only for LPC22xx)&lt;/p&gt;

&lt;p&gt;所谓映射，就是一种对应关系，所以“重映射”就是重新对应的意思&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;逻辑地址  &lt;/th&gt;
&lt;th&gt; MEMMAP  &lt;/th&gt;
&lt;th&gt; 对应物理地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0x00000000~0x0000003F  &lt;/td&gt;
&lt;td&gt; 00   &lt;/td&gt;
&lt;td&gt; 0x7FFFE000~0x7FFFE03F (Boot Block地址)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(同上)  &lt;/td&gt;
&lt;td&gt; 01   &lt;/td&gt;
&lt;td&gt; 0x00000000~0x0000003F (片内Flash地址)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(同上)  &lt;/td&gt;
&lt;td&gt; 10   &lt;/td&gt;
&lt;td&gt; 0x40000000~0x4000003F (片内RAM地址)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(同上)  &lt;/td&gt;
&lt;td&gt; 11   &lt;/td&gt;
&lt;td&gt; 0x80000000~0x8000003F (片外存储器地址)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0x00000040~0xFFFFFFFF  &lt;/td&gt;
&lt;td&gt; 任意   &lt;/td&gt;
&lt;td&gt; 对应不变&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;hr /&gt;

&lt;h2&gt;2．P0 &amp;amp; P1&lt;/h2&gt;

&lt;p&gt;LPC2148有两个32位的通用I/O口：PORT0的32个可用引脚中P0.31为输出引脚，P0.24未用，其余30个为输入/输出引脚；PORT1中P1.16-P1.31引脚可用作GPIO功能。&lt;/p&gt;

&lt;p&gt;PINSEL0、PINSEL1用于选择PORT0，每2bit对应一个引脚(2bit有4种组合，对应4种引脚功能)&lt;/p&gt;

&lt;p&gt;PINSEL0 [31:0]对应P0.15~P0.0&lt;/p&gt;

&lt;p&gt;PINSEL1 [31:0]对应P0.31~P0.16&lt;/p&gt;

&lt;p&gt;PINSEL2直接控制P1.31~P1.0&lt;/p&gt;

&lt;p&gt;IO0SET、IO1SET [31:0]：对应P0.31~P0.0和P1.31~P1.0，往 [n]写1即将Px.n置1，写0无效&lt;/p&gt;

&lt;p&gt;IO0CLR、IO1CLR [31:0]：对应P0.31~P0.0和P1.31~P1.0，往 [n]写1即将Px.n置0，写0无效&lt;/p&gt;

&lt;p&gt;IO0DIR、IO1DIR [31:0]：对应P0.31~P0.0和P1.31~P1.0，往 [n]写1即将Px.n设为output，写0则设为input&lt;/p&gt;

&lt;p&gt;IO0PIN、IO1PIN [31:0]：存储P0.31~P0.0和P1.31~P1.0的当前值(for read)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;3．F &amp;amp; PLL&lt;/h2&gt;

&lt;p&gt;Fosc：晶振频率，在软件中设置时应与实际晶振频率相同，是计算其他频率的基础&lt;/p&gt;

&lt;p&gt;Fcclk：system clock，= M * Fosc，int M∈ [1, 32]，但Fcclk≤60MHz&lt;/p&gt;

&lt;p&gt;Fcco：CCO工作频率，= 2 * P * Fcclk = 2 * P * M * Fosc，int p=1/2/4/8，须满足Fcco∈ [156, 320]MHz&lt;/p&gt;

&lt;p&gt;Fpclk：外设工作频率&lt;/p&gt;

&lt;p&gt;PLLCON：PLL Control&lt;/p&gt;

&lt;p&gt;PLLCON [0]：enable PLL when 1&lt;/p&gt;

&lt;p&gt;PLLCON [1]：connect PLL when 1&lt;/p&gt;

&lt;p&gt;PLLCON [1:0]：00/10-&gt;disabled and not connected; 01-&gt;enabled but not connected; 11-&gt;enabled and connected&lt;/p&gt;

&lt;p&gt;PLLCFG：PLL Config&lt;/p&gt;

&lt;p&gt;PLLCFG [4:0]：将(M-1)的值写入这5位即设置M值&lt;/p&gt;

&lt;p&gt;PLLCFG [6:5]：写入00/01/10/11即设置P值为1/2/4/8&lt;/p&gt;

&lt;p&gt;PLLFEED：设置好PLLCON和PLLCFG后，向PLLFEED先后写入0xAA、0x55才能使设置生效(像点击“确定”一样)&lt;/p&gt;

&lt;p&gt;PLLSTAT：存储PLL的当前状态(for read)&lt;/p&gt;

&lt;p&gt;PLLSTAT [4:0]：当前的PLLCFG [4:0]值&lt;/p&gt;

&lt;p&gt;PLLSTAT [6:5]：当前的PLLCFG [6:5]值&lt;/p&gt;

&lt;p&gt;PLLSTAT [8]：当前的PLLCON [0]值&lt;/p&gt;

&lt;p&gt;PLLSTAT [9]：当前的PLLCON [1]值&lt;/p&gt;

&lt;p&gt;PLLSTAT [10]：PLOCK值，为1时表示PLL已被锁定到设置的频率上。PLOCK在0xAA、0x55 写入PLLFEED后由系统自动设置。必须等待PLOCK为1时才能connect PLL&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;4．PR, PC, TCR, MR, MCR &amp;amp; IR&lt;/h2&gt;

&lt;p&gt;T0PR、T1PR：用来存储Prescale值&lt;/p&gt;

&lt;p&gt;T0PC、T1PC：Prescale Counter，频率为Fpclk，从0开始，递增到Prescale值时，PC置0，TC加1&lt;/p&gt;

&lt;p&gt;T0TC、T1TC：Timer Counter，由PC可知，TC的频率为Fpclk/(Prescale+1)，是整个Timer的中断源&lt;/p&gt;

&lt;p&gt;T0TCR、T1TCR：Timer Control Register&lt;/p&gt;

&lt;p&gt;T0TCR、T1TCR  [0]：enable TC and PC when 1&lt;/p&gt;

&lt;p&gt;T0TCR、T1TCR  [1]：reset TC and PC when 1&lt;/p&gt;

&lt;p&gt;MR0、MR1、MR2、MR3：设置Match值，当TC递增到Match值时产生动作(产生中断、复位TC或是停止TC和PC，这个动作由MCR控制)&lt;/p&gt;

&lt;p&gt;MCR：Match Control Register，控制TC递增到Match值时的动作&lt;/p&gt;

&lt;p&gt;MCR [0]：为1时，TC递增到MR0中的Match值时产生中断&lt;/p&gt;

&lt;p&gt;MCR [1]：为1时，TC递增到MR0中的Match值时复位TC&lt;/p&gt;

&lt;p&gt;MCR [2]：为1时，TC递增到MR0中的Match值时停止TC和PC&lt;/p&gt;

&lt;p&gt;MCR [5:3]：对应MR1，顺序同上&lt;/p&gt;

&lt;p&gt;MCR [8:6]：对应MR2，顺序同上&lt;/p&gt;

&lt;p&gt;MCR [11:9]：对应MR3，顺序同上&lt;/p&gt;

&lt;p&gt;T0IR、T1IR：Interrupt Register，有中断时，对应位置1；往某位写入1则将该位置0 (即复位中断)，写入0无效&lt;/p&gt;

&lt;p&gt;T0IR、T1IR [3:0]：对应timer自身产生的MR3/MR2/MR1/MR0中断&lt;/p&gt;

&lt;p&gt;T0IR、T1IR [7:4]：对应捕获到的外部输入中断，即CR3/CR2/CR1/CR0中断&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;5．向量地址&lt;/h2&gt;

&lt;p&gt;所谓“向量”，就是引导、跳转的意思，“向量地址”实际就是跳转地址 (another example of why I hate translation)&lt;/p&gt;

&lt;p style=&quot;text-align:center;&quot;&gt; ARM7: 8种异常的向量地址&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;异常  &lt;/th&gt;
&lt;th&gt; 向量地址  &lt;/th&gt;
&lt;th&gt; 优先级&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Reset 复位  &lt;/td&gt;
&lt;td&gt; 0x0000 0000   &lt;/td&gt;
&lt;td&gt; 1 (highest)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Undefined Instruction 未定义指令 &lt;/td&gt;
&lt;td&gt; 0x0000 0004   &lt;/td&gt;
&lt;td&gt; 6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Software Interrupt (SWI) 软件中断  &lt;/td&gt;
&lt;td&gt; 0x0000 0008   &lt;/td&gt;
&lt;td&gt; 7 (lowest)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Prefetch Abort (instruction fetch memory fault) 预取指中止  &lt;/td&gt;
&lt;td&gt; 0x0000 000C   &lt;/td&gt;
&lt;td&gt; 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Data Abort (data access memory fault) 数据中止  &lt;/td&gt;
&lt;td&gt; 0x0000 0010   &lt;/td&gt;
&lt;td&gt; 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reserved (used by the Boot Loader as the Valid User Program key) 保留  &lt;/td&gt;
&lt;td&gt; 0x0000 0014   &lt;/td&gt;
&lt;td&gt; N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IRQ  &lt;/td&gt;
&lt;td&gt; 0x0000 0018   &lt;/td&gt;
&lt;td&gt; 4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;hr /&gt;

&lt;h2&gt;6．FIQ&lt;/h2&gt;

&lt;p&gt;发生中断时，ARM只负责(把PC)跳转到向量地址(FIQ to 0x1C, IRQ to 0x18)，后面的工作需要我们自己完成。&lt;/p&gt;

&lt;p&gt;FIQ的ISR可以直接写到0x1C，也可以像IRQ一样，用一个一级ISR取到VICVectAddr中的地址(即是二级ISR的地址)，再运行二级ISR。当然，也可以直接在0x18写IRQ的ISR，不过 ARM 既然提供了这么多类似VICVectAddr的寄存器，不用白不用。&lt;/p&gt;

&lt;p&gt;接下来的问题是：如何把一个函数地址准确地放在0x18/0x1C?&lt;/p&gt;

&lt;p&gt;Yeah, we have &lt;code&gt;#pragma&lt;/code&gt;!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In Programming Languages, Principles and Practice (Boston, PWS-Kent Publishing Co, 1993), Kenneth C. Louden writes&lt;/p&gt;

&lt;p&gt;&quot;Finally, a translator needs to provide the user options for debugging, for interfacing with the operating system, and perhaps with a software development environment. These options, such as specifying files for inclusion, disabling optimizations or turning on tracing or debugging information, are the pragmatics of a programming language translator. Occasionally, facilities for pragmatic directives (实用性指示), or pragmas, are part of the language definition&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;#pragma vector = address&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该命令为其后声明的一个中断函数指定地址，即把中断函数和地址绑定&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#pragma type_attribute = keyword&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该命令影响其后声明的一个函数，keyword包括：&lt;/p&gt;

&lt;p&gt;__arm：使函数以ARM模式运行&lt;/p&gt;

&lt;p&gt;__thumb：使函数以thumb模式运行&lt;/p&gt;

&lt;p&gt;__interwork：使函数既可以以ARM模式运行，也可以以thumb模式运行&lt;/p&gt;

&lt;p&gt;__fiq：声明函数为FIQ函数(ISR)&lt;/p&gt;

&lt;p&gt;__irq：声明函数为IRQ函数(ISR)&lt;/p&gt;

&lt;p&gt;ISR must be compiled in ARM mode. ISR does not accept parameters and does not have a return value.&lt;/p&gt;

&lt;p&gt;__swi：声明函数为软件中断函数(ISR)&lt;/p&gt;

&lt;p&gt;__monitor：声明函数为监视函数&lt;/p&gt;

&lt;p&gt;这些keyword也可以在函数声明时直接使用，如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
__irq __arm interrupt_handler() {
    ...
}
&lt;/pre&gt;


&lt;hr /&gt;

&lt;h2&gt;7．中断引脚&lt;/h2&gt;

&lt;p&gt;LPC2148有32个中断源(部分保留未用)，每个中断源对应一个固定的VIC Channel (VIC Channel #可以看作中断源的编号) (可以理解为每一个中断源有一根固定的信号线连到内核，一有中断就通过这根信号线通知内核)。一些片内中断源已经固定，额外添加的中断源要经过外部中断引脚(EINT)，此时要用到PINSEL，一般使用P0.15和P0.16，因为P0.15对应S4(也就是说S4可以控制P0.15的值，也一点并不只是在P0.15用作GPIO时才成立)，P0.16对应S5，而它们又分别对应EINT2和EINT0 (关于YL所做的内部连接是个让人头痛的问题)&lt;/p&gt;

&lt;p&gt;EXTMODE：设置EXTINT的捕捉模式&lt;/p&gt;

&lt;p&gt;EXTMODE [0]：对应EINT0，置1表示即EXTINT捕捉EINT0引脚上的边沿，0表示EXTINT捕捉EINT0引脚上的电平&lt;/p&gt;

&lt;p&gt;EXTMODE [1]：对应EINT1，同上&lt;/p&gt;

&lt;p&gt;EXTMODE [2]：对应EINT2，同上&lt;/p&gt;

&lt;p&gt;EXTMODE [3]：对应EINT3，同上&lt;/p&gt;

&lt;p&gt;EXTPOLAR：设置EXTINT的捕捉极性&lt;/p&gt;

&lt;p&gt;EXTPOLAR  [0]：对应EINT0，置1表示EXTINT捕捉EINT0引脚上的高电平或是上升沿，0表示EXTINT捕捉EINT0引脚上的低电平或是下降沿&lt;/p&gt;

&lt;p&gt;EXTPOLAR [1]：对应EINT1，同上&lt;/p&gt;

&lt;p&gt;EXTPOLAR [2]：对应EINT2，同上&lt;/p&gt;

&lt;p&gt;EXTPOLAR [3]：对应EINT3，同上&lt;/p&gt;

&lt;p&gt;EXTINT：External Interrupt Flag register (where dose the ‘F’ go?)&lt;/p&gt;

&lt;p&gt;EXTINT [0]：对应EINT0，若捕捉到EINT0上的敏感信号(电平或是边沿)，则该位置1，否则为0，写入1则将该位置0&lt;/p&gt;

&lt;p&gt;EXTINT [1]：对应EINT1，同上&lt;/p&gt;

&lt;p&gt;EXTINT [2]：对应EINT2，同上&lt;/p&gt;

&lt;p&gt;EXTINT [3]：对应EINT3，同上&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;8．中断源&lt;/h2&gt;

&lt;p&gt;32个中断源可以设置为FIQ和IRQ两种模式，有关FIQ和IRQ的处理方式，参见第6点。&lt;/p&gt;

&lt;p&gt;VICIntEnable：使能中断源&lt;/p&gt;

&lt;p&gt;VICIntEnable [x]：置1表示使能第x号中断源(即是VIC Channel #为x的中断源)，写0无效&lt;/p&gt;

&lt;p&gt;VICIntEnClr：禁止中断源&lt;/p&gt;

&lt;p&gt;VICIntEnClr [x]：写入1即将VICIntEnable [x]置0，写0无效&lt;/p&gt;

&lt;p&gt;VICIntSelect：设置中断源&lt;/p&gt;

&lt;p&gt;VICIntSelect [x]：写1表示把第x号中断源设置为FIQ，写0则设置为IRQ&lt;/p&gt;

&lt;p&gt;VICFIQStatus：FIQ Status&lt;/p&gt;

&lt;p&gt;VICFIQStatus [x]：为1表示第x号中断源产生FIQ中断请求&lt;/p&gt;

&lt;p&gt;VICIRQStatus：IRQ Status&lt;/p&gt;

&lt;p&gt;VICIRQStatus [x]：为1表示第x号中断源产生IRQ中断请求&lt;/p&gt;

&lt;p&gt;LPC2148有16个优先级(对应16个slot，0到15优先级从高到低)供IRQ使用，使用slot的IRQ即是向量IRQ，没有使用slot的IRQ即是非向量IRQ&lt;/p&gt;

&lt;p&gt;VICVectAddr0~VICVectAddr15、VICDefVectAddr、VICVectAddr：&lt;/p&gt;

&lt;p&gt;当ISR读取VICVectAddr时，VICVectAddr会先去查找发送过来的最高优先级的VICVectAddrx (若有向量IRQ发生，VIC会把对应的VICVectAddrx发送到VICVectAddr)，若没有VICVectAddrx发送过来 (即没有向量IRQ发生)，则VICVectAddr返回VICDefVectAddr (Def: default)中的地址值&lt;/p&gt;

&lt;p&gt;所以一般把非向量IRQ的地址放在VICDefVectAddr (第6点中提到处理FIQ也可以在一级ISR里读取VICVectAddr，所以FIQ的ISR一般也是写在VICDefVectAddr里的)，如果有多个非向量IRQ或是FIQ中断源，则在ISR里要先用if-else或是swith-case来判断中断源，再做相应的处理。若是非向量IRQ倒也无所谓，反正非向量IRQ不要求处理速度；若是FIQ则会严重影响FIQ的处理速度，所以一般只设置1个FIQ中断源(总之是越少越好)&lt;/p&gt;

&lt;p&gt;“VICVectAddr查找发送过来的最高优先级的VICVectAddrx”实际是通过一个硬件的排序器来实现的，在ISR末尾应向VICVectAddr写入(一般是0x00)来清除硬件排序器中的中断标志&lt;/p&gt;
</description>
                <link>http://erikyao.github.io/arm7/2008/06/18/arm7-notes</link>
                <guid>http://erikyao.github.io/arm7/2008/06/18/arm7-notes</guid>
                <pubDate>2008-06-18T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
